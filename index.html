<!DOCTYPE html>
<html lang="en">
	<head>
		<title>culture heritage viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

		<style>
			.selectBox {
				border: 1px solid #55aaff;
				background-color: rgba(75, 160, 255, 0.3);
				position: fixed;
			}
			div.container4 {
			    height: 100vh;
			    width: 100%;
			    position: absolute }
			div.container4 p {
			    margin: 0;
			    position: absolute;
			    top: 50%;
			    left: 50%;
			    margin-right: -50%;
			    font-size:40px;
			    transform: translate(-50%, -50%) }
			
		</style>

	</head>
	<body>
				<!--script src="scripts/shaders.js"--></script>
		<script src="modules/FileSaver.js"></script>
		<div id="info">
			3D view
		</div>
		<div id="info2">
			2D view
		</div>
		<div class=container4 id="loadingTextContainer">
		  <p id="loadingText">Loading: 0% 
		</div>
		<script>

			let m_container, m_stats, m_gui;

			let m_camera, m_camera_capture, m_camera_capture_orto, m_render_target, m_scene, m_scene_collections, m_camera_collections, m_renderer, m_context;
			const AppStates =
			{
				THREE_JS_INIT: "init_state",
				LOADING_MESHES: "loading_meshes_state",
				LOADING_TEXTURES: "loading_textures_state",
				LOADING_PRECOMPUTED_DATA: "loading_precomputed_state",
				READY_TO_GO: "ready_state",

			}
			var m_camera_list = [];
			var m_camera_mesh_list = [];
			var m_scene_models = [];
			var m_current_candidates = [];
			var m_current_candidates_collections = [];

			var m_controls;
			//var m_controls_secondary;
			var m_camera_mode = "ORBIT";
			var m_timer_update = 0;
			var m_cams_enabled = false;
			var m_current_capture_in_view_index = -1;
			var m_capture_rays_need_recomputation = true;

			const m_num_rays_precomputation = 10;	//rays x rays
			var m_dragging = false;
			var m_current_sprites_in_scene = [];
			var m_selection_rectangle = {
				startNDC: null,
				endNDC: null,
				startWorld: null,
				endWorld: null,
				selectionBox: null,
				helper: null,
			}
			var m_has_any_secondary_capture = false;
			var m_min_pos = null;
			var m_max_pos = null;
			var m_plane_image_secondary = null;
			var m_render_target_secondary = null;
			var m_application_state = 
			{
				state: AppStates.THREE_JS_INIT,
				num_cameras_loaded: 0,
				num_models_loaded: 0,
				three_js_inited: false,
				num_cameras_to_load: 0,
				num_models_to_load: 0,
				precomputed_file_loaded: false,
				precomputation_done: false,
				textures_loaded: false,
				count_precomputation_iterations: 0,
				capture_index_over_mouse: -1,
				transition_animation_step: 1.0,
				views_swaped: false,
				select_controls_enabled: false,
				need_to_update_auto_detect: true,
			}
			var m_debug = 
			{
				debug_mesh_lines: [],
			}

			const m_models_values = []
			m_models_values["doma"] ={
				path: "doma", 
				texture_name: "doma-interior_texture16k.jpg",
				mesh_name: "doma-interior_textured.ply",
				pos_x_cam_start: 11*0.03,
				pos_y_cam_start: -20*0.03,
				pos_z_cam_start: 2*0.03,
			}
			m_models_values["pedret"] ={
				path: "pedret", 
				texture_name: "pedret-interior_meshed_tex.png",
				mesh_name: "pedret-interior_meshed_simplified.ply",
				pos_x_cam_start: 0.0681,
				pos_y_cam_start: 0.0920,
				pos_z_cam_start: 0.0327,
			}
			/*var m_canvas = new fabric.Canvas('canvas');

			m_canvas.setHeight(0);
			m_canvas.setWidth(0);
			m_canvas.renderAll();
			m_canvas.renderAll.bind(m_canvas)();
			m_canvas.backgroundColor = null;*/

			const m_views = [
				{
					left: 0.0,
					bottom: 0.0,
					width: 1.0,
					height: 1.0,
					border_size: 2.0,
				},
				{
					left: 0.7,
					bottom: 0.0,
					width: 0.3,
					height: 0.3,
					border_size: 2.0,
				},
				{
					left: 0.0,
					bottom: 0.0,
					width: 1.0,
					height: 1.0,
					border_size: 2.0,
				}
			];
			var m_gui_options =
			{
				projection: 0,
				orientation: 5,
				position: 1,
				timer_recalc: 1,

				max_num_collections: 7,
				max_collection_size: 5,
				similitude_treshold: 0.7,
				discard_too_similar: true,
				clustering_method: 'normal',
				linkage_enabled: true,

				red_area_enabled: false,
				show_camera_enabled: false,
				show_view_enabled: false,
				show_photo_enabled: false,
				project_capture_enabled: false,
				auto_score_enabled: false,

				current_model: "pedret",

			}






		</script>
		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { PLYLoader } from './jsm/loaders/PLYLoader.js';

			import { OrbitControls } from './jsm/controls/CustomOrbitControls.js';
			import { FlyControls } from './jsm/controls/FlyControls.js';
			import { TrackballControls } from './jsm/controls/CustomTrackballControls.js';
			import { SelectionBox } from './jsm/interactive/SelectionBox.js';
			import { SelectionHelper } from './jsm/interactive/SelectionHelper.js';
			import { VRButton } from './jsm/webxr/VRButton.js';

			//import { saveAs } from './modules/FileSaver.js';

			const m_clock = new THREE.Clock();
			var m_cameraHelper;
			var m_manager = new THREE.LoadingManager();

			var m_old_pos_cam =  new THREE.Vector3();
			
			init();

			


			function createGUI()
			{
				// expressions

				m_gui = new GUI();

				const models = [ 'pedret', 'doma'];

				const modelsFolder = m_gui.addFolder( 'Models' );

				modelsFolder.add( m_gui_options, 'current_model' ).options( models ).name( 'Current model' ).onChange( function () {
					startSceneForModel();
				} );

				modelsFolder.open();

				const scoreFolder = m_gui.addFolder( 'Score computation' );


				scoreFolder.add(m_gui_options, 'projection', 0, 10, 0.1 ).name( 'Projection' );
				scoreFolder.add(m_gui_options, 'position', 0, 10, 0.1 ).name( 'Position' );
				scoreFolder.add(m_gui_options, 'orientation', 0, 10, 0.1 ).name( 'Orientation' );
				scoreFolder.add(m_gui_options, 'timer_recalc', 0, 10, 0.1 ).name( 'Recalc timer' );

				scoreFolder.open();

				const viewFolder = m_gui.addFolder( 'Display options' );


				viewFolder.add(m_gui_options, 'red_area_enabled').name( 'Show area' );
				viewFolder.add(m_gui_options, 'show_camera_enabled').name( 'Show camera' );
				viewFolder.add(m_gui_options, 'show_photo_enabled').name( 'Show photo' );
				viewFolder.add(m_gui_options, 'project_capture_enabled').name( 'Show projection' );
				viewFolder.add(m_gui_options, 'show_view_enabled').name( 'Show view' ).onChange(function ()
					{
						if(m_gui_options.show_view_enabled)
						{
							document.getElementById("info2").style.visibility = "visible";
						}
						else
						{
							document.getElementById("info2").style.visibility = "hidden";
						}
					});
				viewFolder.add(m_gui_options, 'auto_score_enabled').name( 'Auto-detect' );
				viewFolder.open();


				const candidatesFolder = m_gui.addFolder( 'Candidate selection' );

				const clustering_methods = [ 'normal', 'single_linkage'];

				candidatesFolder.add(m_gui_options, 'max_num_collections', 0, 20, 1 ).name( 'Max num collection' );
				candidatesFolder.add(m_gui_options, 'max_collection_size', 0, 20, 1 ).name( 'Max size collection' );
				candidatesFolder.add(m_gui_options, 'similitude_treshold', 0, 1, 0.01 ).name( 'Similitude treshold' );
				//candidatesFolder.add(m_gui_options, 'linkage_enabled').name( 'Linkage clustering' );
				candidatesFolder.add( m_gui_options, 'clustering_method' ).options( clustering_methods ).name( 'Cluster method' );
				candidatesFolder.open();




				//const clusterMethodFolder = m_gui.addFolder( 'Cluster method' );

			}
			function moveToCapturePosition(index_capture)
			{
				var captureCam = m_camera_list[index_capture].mesh
				var direction = new THREE.Vector3();
				captureCam.getWorldDirection( direction );
				m_camera.position.copy( captureCam.position ).add( direction.multiplyScalar( 0.09 ) );
				
				var v1 = new THREE.Vector3(); // create once and reuse it
				m_controls.update()
				
				m_controls.target = new THREE.Vector3( captureCam.position.x, captureCam.position.y, captureCam.position.z );
				//m_controls_secondary.target = new THREE.Vector3( captureCam.position.x, captureCam.position.y, captureCam.position.z );
				//m_controls_secondary.update()
				m_controls.update()
			}
			function changeCaptureInView(index_capture)
			{
				m_has_any_secondary_capture = true
				var directionCapture = new THREE.Vector3();
				var v1 = new THREE.Vector3();
				m_camera_list[index_capture].mesh.getWorldDirection( directionCapture );
				var positionCapture = new THREE.Vector3();
				positionCapture.copy(m_camera_list[index_capture].mesh.position);
				
				/*m_camera_capture.position.set( positionCapture.x,positionCapture.y,positionCapture.z );

				v1.copy( m_camera_list[index_capture].mesh.up ).applyQuaternion( m_camera_list[index_capture].mesh.quaternion );
				m_camera_capture.quaternion.copy( m_camera_list[index_capture].mesh.quaternion );
				m_camera_capture.up.set(v1.x, v1.y, v1.z); 
				*/

				m_camera_capture.copy(m_camera_list[index_capture].camera,true)


				//TODO: GET THIS VALUE FROM FILE:
				m_camera_capture.aspect = m_camera_list[index_capture].width / m_camera_list[index_capture].height;
				m_camera_capture.updateMatrixWorld();
				m_camera_capture.updateProjectionMatrix();
				var viewMat = new THREE.Matrix4();
				var projMat = new THREE.Matrix4();

				var texture, material, plane;

				texture = THREE.ImageUtils.loadTexture( "models/"+m_models_values[m_gui_options.current_model].path+"/captures/"+m_camera_list[index_capture].name );

				viewMat.copy(m_camera_capture.matrixWorldInverse);
				projMat.copy(m_camera_capture.projectionMatrix)
				m_scene_models[0].material.uniforms.viewMatrixCapture.value = viewMat;
				m_scene_models[0].material.uniforms.projectionMatrixCapture.value = projMat;
				m_scene_models[0].material.uniforms.texture2.value = texture;
				m_camera_capture.fov = m_camera_list[index_capture].camera.fov+30

				var frustumHeightWorld_photo = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_list[index_capture].camera.fov * 0.5 ));
				var frustumHeightWorld_view = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
				var scaleFact = frustumHeightWorld_view/frustumHeightWorld_photo;
				//m_camera_capture.render_target_height = m_camera_list[index_capture].height*scaleFact
				//m_camera_capture.render_target_width = m_camera_capture.render_target_height * m_camera_capture.aspect

				//m_render_target_secondary = new THREE.WebGLRenderTarget(m_camera_capture.render_target_width, m_camera_capture.render_target_height);
				

				//TODO: do this init once
				let uniforms = {
				        viewMatrixCapture: {type: 'mat4', value: viewMat},
				        projectionMatrixCapture: {type: 'mat4', value: projMat},
				        showTexture: {type: 'bool', value: true},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: texture }
				    }
				const material_plane = new THREE.ShaderMaterial( { 
						uniforms: uniforms,
					    fragmentShader: fragmentShaderCaptureImage(),
					    vertexShader: vertexShader(),
					    blending: THREE.NormalBlending,
		                depthTest: false,
		                transparent: true
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );

				
				plane = new THREE.Mesh(new THREE.PlaneGeometry(1.0001, 1.0001), material_plane);
				plane.translateZ( -(m_camera_capture.near+0.0001) );
				if(m_plane_image_secondary != null)
				{
					m_scene.remove(m_plane_image_secondary)
				}
				plane.applyMatrix(m_camera_capture.matrix)
				m_plane_image_secondary = plane;
				m_scene.add(m_plane_image_secondary)
				//m_render_target = new THREE.WebGLRenderTarget(m_camera_list[index_capture].width*2, m_camera_list[index_capture].height*2);
				//m_controls_secondary.update()
				/*
				m_camera_capture_orto.up.copy(m_camera_capture.up)
				//m_camera_capture_orto.position.copy(m_camera_capture.position)
				m_camera_capture_orto.position.copy( m_camera_capture.position ).add( directionCapture.multiplyScalar( 0.09 ) );
				m_camera_capture_orto.rotation.copy(m_camera_capture.rotation)
				m_camera_capture_orto.name = m_camera_capture.name;
				//m_camera_capture_orto.updateMatrixWorld();
				m_camera_capture_orto.updateProjectionMatrix();*/

				
				

				/*m_controls_secondary.update()
				m_controls_secondary.target = new THREE.Vector3( m_camera_capture.position.x, m_camera_capture.position.y, m_camera_capture.position.z );
				m_controls_secondary.update()*/

				//m_controls_secondary.target = new THREE.Vector3( m_camera_capture.position.x, m_camera_capture.position.y, m_camera_capture.position.z );
				//m_controls_secondary.update()
			}
			function selectCapture(index_capture, allow_jump = false)
			{
				//var index_capture = m_current_candidates[index_candidate].index;
				if(m_current_capture_in_view_index == index_capture && allow_jump)
				{
					moveToCapturePosition(index_capture)
				}
				else
				{
					changeCaptureInView(index_capture)
				}
				m_current_capture_in_view_index = index_capture;
				
			}



			function showCollectionSprite(min_pos, max_pos, index_capture, order, sprites_to_remove = [], isShifting = false, opacity = 1)
			{

				var scale1 = (max_pos.x -min_pos.x)/m_camera_list[index_capture].width;
				var scale2 = (max_pos.y -min_pos.y)/m_camera_list[index_capture].height;
				var scale = Math.min(scale1, scale2);
				var sprite = m_camera_list[index_capture].sprite;
				var existing = m_scene_collections.getObjectByName(sprite.name);
				var _x = min_pos.x-window.innerWidth/2
				var _y = min_pos.y+window.innerHeight/2
				var spritepos = new THREE.Vector3(_x,_y,0);
				//var spritepos = new THREE.Vector3(0,0,1);

				//sprite.center.set(0,1)
				sprite.scale.set(m_camera_list[index_capture].width*scale, m_camera_list[index_capture].height*scale, 1);
				sprite.position.set(spritepos.x+(m_camera_list[index_capture].width*scale)/2,spritepos.y-(m_camera_list[index_capture].height*scale)/2, spritepos.z);
				sprite.renderOrder = order;
				sprite.name = index_capture;
				//sprite.material.opacity = opacity;
				sprite.material.uniforms.opacity.value = opacity;
				if(!isShifting)
				{
					m_scene_collections.add(sprite);

					m_current_sprites_in_scene.push(sprite)
				}

				if(sprites_to_remove.length > 0)
				{
					const index = sprites_to_remove.indexOf(sprite.name);
					if (index > -1) {
					  sprites_to_remove.splice(index, 1);
					}
				}


				
					

				
			}
			function showCollection(min_pos, max_pos, index_collection, sprites_to_remove = [], isShifting = false, offsetAnim = 0)
			{
				var animOffset = 0;
				if(offsetAnim > 0)
				{
					animOffset = 1-offsetAnim;
				} else if(offsetAnim < 0)
				{
					animOffset = -(offsetAnim+1);
				}
				var currentOffset = new THREE.Vector2(5+animOffset*5,5+animOffset*5)
				var remaining_width = max_pos.x-min_pos.x-currentOffset.x;
				var remaining_height = max_pos.y-min_pos.y-currentOffset.y;
				var offset_per_image = 10;
				var num_elems = m_current_candidates_collections[index_collection].elems.length
				var width_image = remaining_width-num_elems*offset_per_image
				var height_image = remaining_height-num_elems*offset_per_image
				for(var i = num_elems-1; i >= 0; i--)
				{
					var min = new THREE.Vector2( min_pos.x+currentOffset.x, min_pos.y-currentOffset.y );
					var max = new THREE.Vector2( min_pos.x+currentOffset.x+width_image+animOffset*5 ,min_pos.y+currentOffset.y+height_image+animOffset*5);
					currentOffset.x = currentOffset.x + offset_per_image;
					currentOffset.y = currentOffset.y + offset_per_image;
					var opacity = 1
					if(animOffset > 0 && i == 0)
					{
						opacity = 1 - animOffset
					} else if(animOffset < 0 && i == num_elems-1)
					{
						opacity = 1 - animOffset*(-1)
					}
						
					showCollectionSprite(min, max, m_current_candidates_collections[index_collection].elems[i],num_elems-i,sprites_to_remove, isShifting, opacity)
				}
				
			}

			function showCollections()
			{
				var remaining_width = window.innerWidth-200;
				var current_min_x = 0;
				var collection_height = 500
				var sprites_to_remove = []
				

				for(var i = 0; i < m_current_sprites_in_scene.length; i++)
				{
					sprites_to_remove.push(m_current_sprites_in_scene[i].name)
				}
				m_current_sprites_in_scene = []
				for(var i = 0; i < m_current_candidates_collections.length; i++)
				{
					var collection_width = remaining_width/4
					var min = new THREE.Vector2( current_min_x, 0 );
					var max = new THREE.Vector2(current_min_x+ collection_width,collection_height);
					m_current_candidates_collections[i].min = min;
					m_current_candidates_collections[i].max = max;
					showCollection(min,max,i, sprites_to_remove);
					remaining_width = remaining_width - collection_width;
					current_min_x = current_min_x + collection_width;
				}
				//console.log(m_current_candidates_collections.length)
				//console.log(sprites_to_remove)
				for(var i = 0; i < sprites_to_remove.length; i++)
				{
					var existing = m_scene_collections.getObjectByName(sprites_to_remove[i]);
					if(existing)
						m_scene_collections.remove( existing );

				}

			}


			function onDocumentKeyDown(event) {
				if(m_application_state.state == AppStates.READY_TO_GO)
				{
					var keyCode = event.which;
				    if (keyCode == 82) { //R
				        resetCamera();
				    /*} else if (keyCode == 77) { //M
				        changeMode();*/
				    /*}  else if (keyCode == 67) { //C
				        toggleEnableCams();*/
				    }  else if (keyCode == 17) {
				    	m_application_state.select_controls_enabled = true;
				    	m_controls.enabled = false;
				    	//m_controls_secondary.enabled = false;
				    	m_selection_rectangle.helper.element.hidden = false;
				    	
				    	/*m_canvas.setHeight(window.innerHeight);
						m_canvas.setWidth(window.innerWidth);*/
				    }
				}
			};

			function vertexShaderSprite() {
			  return `
			    varying vec2 vUv;

			    void main() {
			    	vUv = uv;
			      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);

			    }
			  `
			}
			function fragmentShaderSprite() {
			  return `
			      uniform vec2 minSel; 
			      uniform vec2 maxSel; 
			      uniform sampler2D texture1;
			      uniform float opacity;

			      varying vec2 vUv;
			      float borderSel = 0.015;
			      void main() {

			      	if(vUv.x > 0.98 || vUv.x < 0.02 || vUv.y > 0.98 || vUv.y < 0.02)
			      	{
			      		gl_FragColor = vec4(0.0,0.0,0.0,1.0);
			      	}
			      	else
			      	{
			      		vec4 color;
			      		if(minSel != maxSel && (
			      			(vUv.x > minSel.x && vUv.x < minSel.x+borderSel && vUv.y > minSel.y && vUv.y < maxSel.y+borderSel) ||
			      			(vUv.y > minSel.y && vUv.y < minSel.y+borderSel && vUv.x > minSel.x && vUv.x < maxSel.x+borderSel) ||
			      			(vUv.x > maxSel.x && vUv.x < maxSel.x+borderSel && vUv.y > minSel.y && vUv.y < maxSel.y+borderSel) ||
			      			(vUv.y > maxSel.y && vUv.y < maxSel.y+borderSel && vUv.x > minSel.x && vUv.x < maxSel.x+borderSel)
			      			))
			      		{
			      			color = vec4(1.0,0.0,0.0,1.0);
			      		}
			      		else
			      		{
			      			color = texture2D(texture1, vUv); 
				      		
			      		}
			      		color.a = opacity;
				      	gl_FragColor = color;
			      		
			      	}
			      }
			  `
			}

			function vertexShader() {
			  return `
			    varying vec2 vUv; 
			    varying vec3 capturePos;
			    varying vec4 modelViewPosition; 
			    varying vec3 vecNormal;
			    uniform mat4 viewMatrixCapture;
			    uniform mat4 projectionMatrixCapture;

			    void main() {
			    	vUv = uv;
			    	vec4 auxCapture = projectionMatrixCapture * viewMatrixCapture * modelMatrix* vec4(position,1.0);
			    	capturePos = vec3(auxCapture.x/auxCapture.w,auxCapture.y/auxCapture.w,auxCapture.z/auxCapture.w);
			    	//capturePos =   (projectionMatrixCapture *  modelViewMatrix * vec4(position,1.0)).xyz;
			      //vUv = position; 
			      //vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
			      //vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz; //????????
			      //gl_Position = projectionMatrix * modelViewPosition; 
			      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);
			      
			      //gl_Position = capturePos;
			    }
			  `
			}
			function fragmentShaderCaptureImage(){
				return `
			      uniform sampler2D texture1;
			      uniform bool showTexture;

			      varying vec2 vUv;
			      varying vec3 capturePos;
			      void main() {
			        //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			        //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			        if(showTexture && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0)
			        {
			        		vec2 texCoords = vec2((capturePos.x+1.0f)/2.0f,(capturePos.y+1.0f)/2.0f);
			        		gl_FragColor = texture2D(texture1, texCoords);
			        }
			        else 
			        {
			        	discard;
						//gl_FragColor = texture2D(texture1, vUv); 
						//discard;
			        }

			      }
			  `
			}
			function fragmentShader() {
			  return `
			      uniform sampler2D texture1;
			      uniform sampler2D texture2;
			      uniform bool showRedArea;
			      uniform bool projectCapture;
			      varying vec2 vUv;
			      varying vec3 capturePos;
			      void main() {
			        //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			        //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			        if(showRedArea && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			        {

			        	if(capturePos.x < -0.95 || capturePos.x > 0.95 || capturePos.y < -0.95 || capturePos.y > 0.95)
			        		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.6), 1.0);
			        	else
			        		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.8), 1.0);
			        }
			        else 
			        {
			        	if(projectCapture && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			        	{
			        		vec2 texCoords = vec2((capturePos.x+1.0f)/2.0f,(capturePos.y+1.0f)/2.0f);
			        		gl_FragColor = texture2D(texture2, texCoords);
			        	}
			        	else
			        	{
			        		gl_FragColor = texture2D(texture1, vUv); 
			        	}
						
						//discard;
			        }

			        
			         
			      }
			  `
			}
			



			function onDocumentPointerMove(event)
			{
				if(!m_application_state.state == AppStates.READY_TO_GO)
					return;
				var captureIndex = getCaptureUnderMouse(event);
				if(captureIndex >= 0)
				{
					//console.log("mouse move, capture: "+ captureIndex)
					if(m_application_state.capture_index_over_mouse != captureIndex && !m_application_state.select_controls_enabled)
						selectCapture(captureIndex)
					m_application_state.capture_index_over_mouse = captureIndex;
					m_controls.enabled = false;
					//m_controls_secondary.enabled = false;
				}
				else
				{
					if(!m_application_state.select_controls_enabled && !m_application_state.views_swaped)
					{
						m_controls.enabled = true;
					}
						
					/*if(m_application_state.views_swaped)
						m_controls_secondary.enabled = true;*/
					m_application_state.capture_index_over_mouse = -1;
				}
					
				if(m_application_state.select_controls_enabled && m_dragging)
				{
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
				                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
				                                    0.5 );   
					m_selection_rectangle.endNDC = mouseNDC

					m_selection_rectangle.selectionBox.endPoint.set(
									( event.clientX / window.innerWidth ) * 2 - 1,
									- ( event.clientY / window.innerHeight ) * 2 + 1,
									0.5 );
				}
				else
				{

				}
			}
			function getCaptureUnderMouse(event)
			{
	            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );     
	            var raycaster =  new THREE.Raycaster();                                        
	           raycaster.setFromCamera( mouse3D, m_camera_collections );
	            var intersects = raycaster.intersectObjects( m_current_sprites_in_scene );
				//console.log(intersects)
				setDefaultColorsCameras();

	            if ( intersects.length > 0 ) 
	            {
	            	var curr_index = intersects[ 0 ].object.name
	            	var curr_depth = intersects[ 0 ].object.renderOrder
	            	for(var i=0; i <intersects.length; i++)
	            	{
	            		if(intersects[ i ].object.renderOrder > curr_depth)
	            		{
	            			curr_depth = intersects[ i ].object.renderOrder;
	            			curr_index = intersects[ i ].object.name;
	            		}
	            	}
	            	return curr_index
	            }
	            else
	            	return -1
			}
			function getCollectionIndexUnderMouse(event)
			{
				if(m_application_state.capture_index_over_mouse != -1)
				{
					var index_collection = -1
					for(var i=0; i<m_current_candidates_collections.length; i++)
					{
						for(var j=0; j < m_current_candidates_collections[i].elems.length; j++)
						{
							if(m_current_candidates_collections[i].elems[j] == m_application_state.capture_index_over_mouse)
							{
								index_collection = i;
								break;
							}
						}
						
					}
					return index_collection;
				}
				return -1;
			}
			function onDocumentPointerDown(event)
			{
				if(!m_application_state.state == AppStates.READY_TO_GO)
				return;
				if(m_application_state.select_controls_enabled)
				{
					//document.getElementById("selection_menu").style.display = "none";
					GUI.toggleHide();
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
				                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
				                                    0.5 );   
					
					m_selection_rectangle.startNDC = mouseNDC
					m_selection_rectangle.endNDC = mouseNDC
					var auxNDC = new THREE.Vector2(mouseNDC.x, mouseNDC.y);

					
					//console.log("NDC down" + mouseNDC);
					m_dragging = true;

					m_selection_rectangle.selectionBox.startPoint.set(
								( event.clientX / window.innerWidth ) * 2 - 1,
								- ( event.clientY / window.innerHeight ) * 2 + 1,
								0.5 );
				}
				else
				{
					if(m_gui_options.show_view_enabled)
					{
						var mouseWindwNorm = new THREE.Vector3( ( event.clientX / window.innerWidth ),   
				                                    1-( event.clientY / window.innerHeight ),  
				                                    0.5 );   
						

						console.log(mouseWindwNorm)
						if(mouseWindwNorm.x >m_views[1].left && mouseWindwNorm.x < m_views[1].left +m_views[1].width && mouseWindwNorm.y >m_views[1].bottom && mouseWindwNorm.y <m_views[1].bottom+m_views[1].height)
						{
							m_application_state.views_swaped = !m_application_state.views_swaped;
							if(m_application_state.views_swaped)
							{
								document.getElementById("info").innerHTML  = "2D view";
								document.getElementById("info2").innerHTML  = "3D view";
								//m_controls_secondary.enabled = true;
								m_controls.enabled = false;
								console.log("SET TO FALSE NEN")
							}
							else
							{
								document.getElementById("info").innerHTML  = "3D view";
								document.getElementById("info2").innerHTML  = "2D view";
								//m_controls_secondary.enabled = false;
								m_controls.enabled = true;
								console.log("SET TO TRU NEN")
							}
						}
					}
					

				}
			}

			function onDocumentMouseWheel(event)
			{
				//console.log("here we go again")
				/*var captureIndex = getCaptureUnderMouse(event);
				if(captureIndex >= 0)
					console.log(captureIndex)*/

				var collection = getCollectionIndexUnderMouse(event)
				//console.log(collection)
				if(collection >=0 && m_current_candidates_collections[collection].elems.length > 1)
				{
					if(event.wheelDelta > 0)
					{
						m_current_candidates_collections[collection].animating = 1
					}
					else
					{
						m_current_candidates_collections[collection].animating = -1
					}
				}

			}
			function onDocumentPointerUp( event ) {   
				if(!m_application_state.state == AppStates.READY_TO_GO)
					return;
				if(m_application_state.select_controls_enabled)
				{
					//document.getElementById("selection_menu").style.display = "block";
					GUI.toggleHide();
					m_dragging = false;
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );   
					m_selection_rectangle.endNDC = mouseNDC

					
					//console.log("NDC up" + mouseNDC);

					m_selection_rectangle.selectionBox.endPoint.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1,
					0.5 );

					updateCandidates(true);
				}
				else
				{
					var captureIndex = getCaptureUnderMouse(event);
					if(captureIndex >= 0)
						selectCapture(captureIndex, true)
				}
				return;
				//console.log("pointer up")
				
				if(!m_cams_enabled || !m_application_state.state == AppStates.READY_TO_GO)
					return;
				if(m_camera_mode == "FLY")
					return;
				//console.log(m_camera_mode)
	            event.preventDefault();
	            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );     
	            var raycaster =  new THREE.Raycaster();                                        
	           raycaster.setFromCamera( mouse3D, m_camera );
	            var intersects = raycaster.intersectObjects( m_camera_mesh_list );
				//console.log(intersects)
				setDefaultColorsCameras();
	            if ( intersects.length > 0 ) {
	            	var photoIndex = -1;
	            	for (var i = 0; i < m_camera_list.length; i++) {
					    if(intersects[ 0 ].object.id == m_camera_list[i].mesh.id)
					    	photoIndex = i;
					}
					//console.log(photoIndex);
					//console.log(m_camera_list)
					//console.log(captureNames)
					//m_controls.coupleCenters = false;
					//showCapture(photoIndex);
	                intersects[ 0 ].object.material.color.setHex( 0x0000ff );
	                intersects[ 0 ].object.material.opacity = 0.3; 
	                var direction = new THREE.Vector3();
					intersects[ 0 ].object.getWorldDirection( direction );
					//m_controls.enabled = false;
					//m_camera.position.copy( intersects[ 0 ].object.position )
					m_camera.position.copy( intersects[ 0 ].object.position ).add( direction.multiplyScalar( 0.09 ) );
					
					//m_camera.quaternion.copy( intersects[ 0 ].object.quaternion );

					var v1 = new THREE.Vector3(); // create once and reuse it

					v1.copy( intersects[ 0 ].object.up ).applyQuaternion( intersects[ 0 ].object.quaternion );
					m_camera.up.set(v1.x, v1.y, v1.z); 
					//m_camera.lookAt(intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z)
					m_controls.update()
					//m_controls.update()
					//m_controls.coupleCenters = true;
					
					m_controls.target = new THREE.Vector3( intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z );
					//m_controls.target.copy(v1.x, v1.y, v1.z)
					//m_controls.target.add( direction.multiplyScalar( 0.5 ) );
					m_controls.update()
					

	            }
	            else
	            {
	            	//document.getElementById("captureImage").style.visibility = "hidden";
	            	//console.log(m_camera)
	            	//console.log(controls)
	            }
	        }


	        function setDefaultColorsCameras()
	        {

	        	var arrayLength = m_camera_list.length;
				for (var i = 0; i < arrayLength; i++) {
				    m_camera_list[i].mesh.material.color.setHex( 0xffffff );
				    m_camera_list[i].mesh.material.opacity = 0.0; 
				    //Do something
				}
	        }
			function loadCamera(element, index, array)
			{
				
				//https://github.com/colmap/colmap/issues/797
				//https://github.com/colmap/colmap/issues/572
				console.log("      Loading Camera "+element.name+" ...")
				 const loader = new PLYLoader();
				 loader.load( './assets/camera.ply', function ( geometry ) {

				 	var m = new THREE.Matrix4();
					m.set( element.m1, element.m2, element.m3, element.tx,
			           element.m4, element.m5, element.m6, element.ty,
			           element.m7, element.m8, element.m9, element.tz,
			           0, 0, 0, 1 );
					m.invert();

					geometry.computeVertexNormals();
					const edges = new THREE.EdgesGeometry( geometry );
					//const material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
					const material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );

					material.transparent = true;
					material.opacity = 0.1; 
					//const mesh = new THREE.LineSegments( geometry, material );
					//const mesh = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } ) );
					const mesh = new THREE.Mesh( geometry, material );

					mesh.applyMatrix4(m);
					mesh.applyMatrix4(new THREE.Matrix4().makeScale(0.03, 0.03, 0.03))
					mesh.castShadow = false;
					mesh.receiveShadow = false;
					m_scene.add( mesh );



					var fov_y = 2*Math.atan(element.height/(2*element.f))
					var fov_x = 2*Math.atan(element.width/(2*element.f))


					//console.log("FOVS: "+fov_y + " "+fov_x)
					var capture_camera = new THREE.PerspectiveCamera( fov_y*(180/Math.PI), element.width / element.height, 0.01, 10 );


					capture_camera.position.set( mesh.position.x,mesh.position.y,mesh.position.z );
					capture_camera.name = element.name
						/////////////

						//capture_camera.setFocalLength(element.f*(180/3.14))
						var v1 = new THREE.Vector3();
					v1.copy(mesh.up ).applyQuaternion(mesh.quaternion );
					capture_camera.quaternion.copy(mesh.quaternion );
					capture_camera.up.set(v1.x, v1.y, v1.z); 

					//capture_camera.aspect = element.width/element.height;

					capture_camera.updateMatrixWorld();
					capture_camera.updateProjectionMatrix();
					
					////////////////////////

					const texture_sprite = new THREE.TextureLoader().load( 'models/'+m_models_values[m_gui_options.current_model].path+'/thumbnails/'+element.name);
					//const material_sprite = new THREE.SpriteMaterial( { map: texture_sprite } );

					let uniformsSprite = {
				        minSel: {type: 'vec2', value: new THREE.Vector2(0,0)},
				        maxSel: {type: 'vec2', value: new THREE.Vector2(0,0)},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: texture_sprite },
				        opacity: {type: 'f', value: null },

				    }
					const material_sprite = new THREE.ShaderMaterial( { 
						uniforms: uniformsSprite,
					    fragmentShader: fragmentShaderSprite(),
					    vertexShader: vertexShaderSprite(),
					    blending: THREE.NormalBlending,
		                depthTest: false,
		                transparent: true
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );
					var geometry_sprite = new THREE.PlaneGeometry(1,1);
					const sprite = new THREE.Mesh(geometry_sprite, material_sprite);

					


					//m_scene.add( sprite );


					var new_camera = {
						name: element.name,
						width: element.width,
						height: element.height,
						matrix: m,
						focal: element.f,
						mesh: mesh,
						sprite: sprite,
						camera: capture_camera,
						similitudes: [],
						similitudes_indices_ordered: [],
						rays: [],
					}
					m_camera_list.push(new_camera);
					/*var loader2 = new THREE.TextureLoader();
					var texture = loader2.load( "./thumbnails/"+element.name, function ( tex ) {
					    // tex and texture are the same in this example, but that might not always be the case
					    new_camera.width = tex.image.width
					    new_camera.height = tex.image.height
					    capture_camera.aspect = new_camera.width/new_camera.height;
					    //console.log( tex.image.width, tex.image.height );
					    //console.log( texture.image.width, texture.image.height );
					} );*/

					m_camera_mesh_list.push(mesh);
					setDefaultColorsCameras()
					m_application_state.num_cameras_loaded +=1

					var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
					document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";
					if(m_min_pos == null)
					{
						m_min_pos = new THREE.Vector3(mesh.position.x,mesh.position.y,mesh.position.z)
					}
					if(m_max_pos == null)
					{
						m_max_pos = new THREE.Vector3(mesh.position.x,mesh.position.y,mesh.position.z)
					}
					if(m_min_pos.x > mesh.position.x)
						m_min_pos.x = mesh.position.x
					if(m_min_pos.y > mesh.position.z)
						m_min_pos.y = mesh.position.z
					if(m_min_pos.z > mesh.position.z)
						m_min_pos.z = mesh.position.z

					if(m_max_pos.x < mesh.position.x)
						m_max_pos.x = mesh.position.x
					if(m_max_pos.y < mesh.position.z)
						m_max_pos.y = mesh.position.z
					if(m_max_pos.z < mesh.position.z)
						m_max_pos.z = mesh.position.z
					console.log("      Loading Camera "+element.name+" : DONE")
					//console.log("CAMERA LOADED")

				} );

			}
			
			function loadCameras(cameras) {
				m_application_state.num_cameras_to_load = cameras.cameras.length
				console.log("INFO: Loading cameras...")
				cameras.cameras.forEach(loadCamera);
			}
			function loadModel()
			{
				console.log("INFO: Loading "+m_gui_options.current_model+"...")
				const loader = new PLYLoader();
				const loaderTex = new THREE.TextureLoader(m_manager);



				loader.load( './models/'+m_models_values[m_gui_options.current_model].path+'/meshes/'+m_models_values[m_gui_options.current_model].mesh_name, function ( geometry ) {
					geometry.computeVertexNormals();
					let uniforms = {
				        viewMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        projectionMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        showRedArea: {type: 'bool', value: false},
				        projectCapture: {type: 'bool', value: false},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: loaderTex.load('./models/'+m_models_values[m_gui_options.current_model].path+'/textures/'+m_models_values[m_gui_options.current_model].texture_name) },
				        texture2: { type: "t", value: null },
				    }
					const material = new THREE.ShaderMaterial( { 
						uniforms: uniforms,
					    fragmentShader: fragmentShader(),
					    vertexShader: vertexShader(),
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );
					const mesh = new THREE.Mesh( geometry, material );
					mesh.scale.multiplyScalar( 0.03 );
					//mesh.rotation.x = - Math.PI / 2;
					mesh.position.x = 0.0;
					mesh.position.y = 0.0;
					mesh.position.z = 0.0;
					
					 

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					m_scene.add( mesh );
					m_scene_models.push(mesh);

					//TODO Check cams loaded
					m_application_state.num_models_loaded +=1
					console.log("INFO: Loading Model: DONE")
					var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
					document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";

					//precomputeRays()

				} );
			} 
			
			function loadModels()
			{
				m_application_state.num_models_to_load = 1
				loadModel();
				//m_scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

				//addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				//addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 );


			}
			function resetCamera()
			{
				initControls(m_camera_mode)
			}
			function toggleEnableCams()
			{
				m_cams_enabled = !m_cams_enabled;
				var arrayLength = m_camera_list.length;
				if(m_cams_enabled)
				{
					for (var i = 0; i < arrayLength; i++) {
					    m_camera_list[i].mesh.material.opacity = 0.1; 
					}
				}
				else
				{
					for (var i = 0; i < arrayLength; i++) {
					    m_camera_list[i].mesh.material.opacity = 0.0; 
					}
				}
			}
			function getScorePosition(index_cam)
			{
				var dist_max_aprox = (m_min_pos.distanceTo(m_max_pos))*2
				var dist = m_camera_list[index_cam].mesh.position.distanceTo(m_camera.position)
				if(dist > dist_max_aprox)
					dist = dist_max_aprox;
				return (dist_max_aprox-dist)/dist_max_aprox;
				
			}
			function getScoreRotation(index_cam)
			{
				var direction1 = new THREE.Vector3();
				var direction2 = new THREE.Vector3();
				m_camera_list[index_cam].mesh.getWorldDirection( direction1 );
				m_camera.getWorldDirection( direction2 );
				var dist = direction1.distanceTo(direction2);
				return dist/2;
				
			}
			function getScoreRays(index_cam, intersectsCamera, min_x, max_x, min_y, max_y)
			{
				//if(intersectsCamera.length == 0)
				//	return 1;
				/*var directionPhoto = new THREE.Vector3();
				m_camera_list[index_cam].getWorldDirection( directionPhoto );
				var raycasterPhoto =  new THREE.Raycaster(m_camera_list[index_cam].position, directionPhoto); 

				var intersectsPhoto = raycasterPhoto.intersectObjects( m_scene_models );  

				if(intersectsPhoto.length == 0)
					return 1;*/

				m_camera.updateProjectionMatrix();
				var count_inside_rays = 0

				for(var index_ray = 0; index_ray <m_camera_list[index_cam].rays.length; ++index_ray)
				{
					var projected = new THREE.Vector3();
					projected.copy(m_camera_list[index_cam].rays[index_ray])
					projected.project(m_camera)
					//console.log(projected)
					if(projected.x > min_x && projected.x < max_x && projected.y > min_y && projected.y < max_y)
					{
						//console.log("added " + index_cam)
						count_inside_rays = count_inside_rays +1
					}
						
				}
				if(m_camera_list[index_cam].rays.length > 0)
					return count_inside_rays/m_camera_list[index_cam].rays.length
				else
					return 0
				//return intersectsPhoto[0].point.distanceTo(intersectsCamera[0].point);
				

			}
			function getWorldIntersectFromNDCxy(camera, ndc_pos, models)
			{
				camera.updateProjectionMatrix();
				var NDC_position = new THREE.Vector3(ndc_pos.x,ndc_pos.y,1);
				var pointIntersect = new THREE.Vector3();
				NDC_position.unproject(camera);

				//m_camera_list[i].getWorldDirection( directionPhoto );
				//var raycasterPhoto =  new THREE.Raycaster(camera.position, NDC_position,0, 10000); 

				 var raycaster =  new THREE.Raycaster();  

	           	raycaster.setFromCamera( ndc_pos, camera );

				var intersectsPhoto = raycaster.intersectObjects( models );  




				////////////////////////////////////// BEGIN
				/*const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
				const points = [];

				points.push( camera.position );
				points.push( NDC_position );
				

				const geometry = new THREE.BufferGeometry().setFromPoints( points );
				const line = new THREE.Line( geometry, material );
				m_scene.add( line );
				m_debug.debug_mesh_lines.push(line)*/

				//console.log(intersectsPhoto)
				//console.log(ndc_pos)
				//////////////////////////////////// END
				if(intersectsPhoto.length > 0)
				{
					pointIntersect.copy(intersectsPhoto[0].point)
					////////////////////////// BEGIN
					/*const geometry2 = new THREE.SphereGeometry( 0.5, 32, 32 );
					const material2 = new THREE.MeshBasicMaterial( {color: 0xffff00} );
					var sphere = new THREE.Mesh( geometry2, material2 );
					sphere.position.set(pointIntersect.x,pointIntersect.y,pointIntersect.z);
					sphere.name ="theball"
					sphere.scale.set( 0.01,0.01,0.01);
					m_scene.add( sphere );
					//////////////////////////// END*/
					return pointIntersect;
				} 
				else
				{
					return null;
				}
			}
			function getNDCposFromWorld(camera, worldpos)
			{
				if(worldpos == null)
					return null;
				var projected = new THREE.Vector3();
				projected.copy(worldpos)
				projected.project(camera)
				return projected;
			}
			function getScoreCam(index_cam, intersectsCamera, usingSelectionRectangle)
			{
				var distanceScore, orientationScore, raysScore;
				distanceScore = orientationScore = raysScore = 0;
				if(usingSelectionRectangle)
				{
					raysScore = getScoreRays(index_cam, intersectsCamera,m_selection_rectangle.startNDC.x,m_selection_rectangle.endNDC.x,m_selection_rectangle.startNDC.y,m_selection_rectangle.endNDC.y);

					var minNDCpoint = getNDCposFromWorld(m_camera_list[index_cam].camera, m_selection_rectangle.startWorld)
					var maxNDCpoint = getNDCposFromWorld(m_camera_list[index_cam].camera, m_selection_rectangle.endWorld)
					//console.log("minmax")
					//console.log(minNDCpoint)
					//console.log(maxNDCpoint)
					if(minNDCpoint != null && maxNDCpoint !=null)
					{
						if(minNDCpoint.x >maxNDCpoint.x)
						{
							var aux = minNDCpoint.x;
							minNDCpoint.x = maxNDCpoint.x;
							maxNDCpoint.x = aux;
						}
						if(minNDCpoint.y >maxNDCpoint.y)
						{
							var aux = minNDCpoint.y;
							minNDCpoint.y = maxNDCpoint.y;
							maxNDCpoint.y = aux;
						}
						m_camera_list[index_cam].sprite.material.uniforms.minSel.value = new THREE.Vector2((minNDCpoint.x+1)/2,(minNDCpoint.y+1)/2);
						m_camera_list[index_cam].sprite.material.uniforms.maxSel.value = new THREE.Vector2((maxNDCpoint.x+1)/2,(maxNDCpoint.y+1)/2);
					}
					else
					{
						m_camera_list[index_cam].sprite.material.uniforms.minSel.value = new THREE.Vector2(0.0,0.0);
						m_camera_list[index_cam].sprite.material.uniforms.maxSel.value = new THREE.Vector2(0.0,0.0);
					}
					
					return raysScore;
				}
				else
				{
					if(m_gui_options.position)
						distanceScore = getScorePosition(index_cam);
					if(m_gui_options.orientation)
						orientationScore = getScoreRotation(index_cam);
					if(m_gui_options.projection)
						raysScore = getScoreRays(index_cam, intersectsCamera,-1,1,-1,1);

					m_camera_list[index_cam].sprite.material.uniforms.minSel.value = new THREE.Vector2(0.0,0.0);
					m_camera_list[index_cam].sprite.material.uniforms.maxSel.value = new THREE.Vector2(0.0,0.0);
					return distanceScore*m_gui_options.position + orientationScore*m_gui_options.orientation + raysScore*m_gui_options.projection;
				}

				
			}
			function compareCanditateIndices( a, b ) {
			  if ( a.index < b.index ){
			    return -1;
			  }
			  if ( a.index > b.index ){
			    return 1;
			  }
			  return 0;
			}
			function compareCandidates( a, b ) {
			  if ( a.score > b.score ){
			    return -1;
			  }
			  if ( a.score < b.score ){
			    return 1;
			  }
			  return 0;
			}
			function compareSimilitudes( a, b ) {
			  if ( a.similitude > b.similitude ){
			    return -1;
			  }
			  if ( a.similitude < b.similitude ){
			    return 1;
			  }
			  return 0;
			}

			function shiftCollectionSprites(collection,index, direction)
			{
				if(direction > 0)
				{
					var elem = collection.elems.shift()
					collection.elems.push(elem)
					//console.log("shifted1")
				} else
				{
					var elem = collection.elems.pop();
					collection.elems.unshift(elem);
					//console.log("shifted2")
				}
				
			}
			function updateCollectionsAnims(delta)
			{
				for(var i=0; i < m_current_candidates_collections.length; i++)
				{
					if(m_current_candidates_collections[i].animating !=0)
					{
						var value_shift = m_current_candidates_collections[i].animating
						if(m_current_candidates_collections[i].animating >0)
						{
							m_current_candidates_collections[i].animating = m_current_candidates_collections[i].animating - delta*2;
							if(m_current_candidates_collections[i].animating < 0)
								m_current_candidates_collections[i].animating = 0
						}
						else 
						{
							m_current_candidates_collections[i].animating = m_current_candidates_collections[i].animating + delta*2;
							if(m_current_candidates_collections[i].animating > 0)
								m_current_candidates_collections[i].animating = 0
						}
						if(m_current_candidates_collections[i].animating == 0)
							shiftCollectionSprites(m_current_candidates_collections[i],i, value_shift)
						var offset = m_current_candidates_collections[i].animating
						showCollection(m_current_candidates_collections[i].min, m_current_candidates_collections[i].max,i, [], true, offset)
					}
				}
				//m_application_state.
			}
			function singleLinkageClustering(num_clusters, num_elements_per_cluster)
			{


				m_current_candidates_collections = []
				for (var i = 0; i < m_current_candidates.length; i++) {

					var aux_collection_elem = {
						score: 0,
						elems: null,
						distances: null,
						animating: 0,
						min: null,
						max: null,
					}
					m_current_candidates_collections.push(aux_collection_elem);
				}
				for (var i = 0; i < m_current_candidates.length; i++) {
					var pair_elem_score = {
						elem: m_current_candidates[i].index,
						similitude: m_current_candidates[i].score,
					}
					m_current_candidates_collections[m_current_candidates[i].index].elems = [pair_elem_score]
					m_current_candidates_collections[m_current_candidates[i].index].distances = m_camera_list[m_current_candidates[i].index].similitudes.slice()
				}
				while(m_current_candidates_collections.length > num_clusters)
				{
					var mindist = 
					{
						c1: null,
						c2: null,
						dist: -1, //1 is the maximum distance allowed
					}
					for(var i = 0; i < m_current_candidates_collections.length; i++)
					{
						for(var j = i+1; j < m_current_candidates_collections[i].distances.length; j++)
						{
							if(m_current_candidates_collections[i].distances[j] > mindist.dist)
							{
								mindist.dist = m_current_candidates_collections[i].distances[j]
								mindist.c1 = i
								mindist.c2 = j
								//console.log("updated ("+i+","+j+") "+m_camera_list[m_current_candidates_collections[mindist.c1].elems[0].elem].name+ " with "+m_camera_list[m_current_candidates_collections[mindist.c2].elems[0].elem].name+ " -> "+mindist.dist+ " <-> " +m_camera_list[m_current_candidates_collections[mindist.c1].elems[0].elem].similitudes[mindist.c2])
							}
							if(mindist.dist==1)
								break;
						}
						if(mindist.dist==1)
								break;
					}
					
					if(mindist.c1 > mindist.c2)
					{
						var c_aux = mindist.c1
						mindist.c1 = mindist.c2
						mindist.c2 = c_aux
					}

					var newdistances = []
					for(var i=0; i < m_current_candidates_collections.length; i++)
					{
						var val1 = m_current_candidates_collections[mindist.c1].distances[i]
						var val2 = m_current_candidates_collections[mindist.c2].distances[i]
						if(i != mindist.c1 && i != mindist.c2)
							newdistances.push(Math.max(val1,val2))
					}
					newdistances.push(1)
					var aux_collection_elem = {
						score: 0,
						elems: m_current_candidates_collections[mindist.c1].elems.concat(m_current_candidates_collections[mindist.c2].elems),
						distances: newdistances.slice(),
						animating: 0,
						min: null,
						max: null,
					}
					//console.log("joined "+m_camera_list[m_current_candidates_collections[mindist.c1].elems[0].elem].name+ " with "+m_camera_list[m_current_candidates_collections[mindist.c2].elems[0].elem].name)
					m_current_candidates_collections.splice(mindist.c2,1)
					m_current_candidates_collections.splice(mindist.c1,1)
					for(var i = 0; i < m_current_candidates_collections.length; i++)
					{
						m_current_candidates_collections[i].distances.splice(mindist.c2,1)
						m_current_candidates_collections[i].distances.splice(mindist.c1,1)
						m_current_candidates_collections[i].distances.push(aux_collection_elem.distances[i])
					}
					m_current_candidates_collections.push(aux_collection_elem)
				}
				
				for(var i = 0; i < m_current_candidates_collections.length; i++)
				{
					m_current_candidates_collections[i].elems.sort(compareSimilitudes)
					var aux_array = []
					for(var j = 0; j < Math.min(num_elements_per_cluster,m_current_candidates_collections[i].elems.length); j++)
						aux_array.push(m_current_candidates_collections[i].elems[j].elem)
					if(m_current_candidates_collections[i].elems.length >0)
						m_current_candidates_collections[i].score = m_current_candidates_collections[i].elems[0].similitude
					m_current_candidates_collections[i].elems = aux_array
				}
				m_current_candidates_collections.sort(compareCandidates)
			}
			function basicClustering(num_clusters, num_elements_per_cluster, treshold)
			{
				var aux_candidate_list = []
				for (var i = 0; i < m_current_candidates.length; i++) {
					aux_candidate_list.push(m_current_candidates[i])
				}
				aux_candidate_list.sort(compareCanditateIndices)
				m_current_candidates_collections = []
				var current_collection_index = 0
				for (var i = 0; i < m_current_candidates.length; i++) {
					if(m_current_candidates[i].collection_index == -1 && m_current_candidates_collections.length < num_clusters)
					{
						var aux_collection_elem = {
							score: m_current_candidates[i].score,
							elems: [m_current_candidates[i].index],
							animating: 0,
							min: null,
							max: null,
						}
						m_current_candidates_collections.push(aux_collection_elem)
						m_current_candidates[i].collection_index=current_collection_index;
						var reached_treshold = false;
						var aux_index_capture = 0;
						while(!reached_treshold && aux_index_capture < m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered.length)
						{
							if(m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].similitude > treshold)
							{

								if(aux_candidate_list[m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index].collection_index == -1)
								{

									aux_candidate_list[m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index].collection_index = current_collection_index;

									if(m_current_candidates_collections[current_collection_index].elems.length < num_elements_per_cluster)
									{
										m_current_candidates_collections[current_collection_index].elems.push(m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index)
									}
									
								}
							}
							else
							{
								reached_treshold = true;
							}
							aux_index_capture = aux_index_capture+1;
						}
						current_collection_index = current_collection_index +1
					}
					else if(m_current_candidates_collections.length >= m_gui_options.max_num_collections)
						break;
				}
			}
			function updateCandidateCollections()
			{
				if(m_gui_options.clustering_method == 'single_linkage')
					singleLinkageClustering(m_gui_options.max_num_collections, m_gui_options.max_collection_size);
				else
					basicClustering(m_gui_options.max_num_collections, m_gui_options.max_collection_size, m_gui_options.similitude_treshold);
				/*switch(m_gui_options.linkage_enabled)
				{
					case false:
					{
						singleLinkageClustering(m_gui_options.max_num_collections, m_gui_options.max_collection_size);
						break;
					}
					
					case true:
					{
						basicClustering(m_gui_options.max_num_collections, m_gui_options.max_collection_size, m_gui_options.similitude_treshold);
						break;
					}
				}*/
				

			}
			function normalizeScores()
			{
				var biggest_score = m_current_candidates[0].score;
				for (var i = 0; i < m_current_candidates.length; i++) {
					m_current_candidates[i].score = m_current_candidates[i].score/biggest_score;
				}
			}
			function updateCandidates(usingSelectionRectangle)
			{
				console.log("INFO: Updating candidates...")
				var directionCamera = new THREE.Vector3();
				m_camera.getWorldDirection( directionCamera );
				var raycasterCamera =  new THREE.Raycaster(m_camera.position, directionCamera);    
				var intersectsCamera = raycasterCamera.intersectObjects( m_scene_models );  
				//console.log(intersectsCamera);

				var changed = false
				m_current_candidates = []
				var arrayLength = m_camera_list.length;

				if(usingSelectionRectangle)
				{
					var minWorldPoint = getWorldIntersectFromNDCxy(m_camera,m_selection_rectangle.startNDC,m_scene_models);
					var maxWorldPoint = getWorldIntersectFromNDCxy(m_camera,m_selection_rectangle.endNDC,m_scene_models);
					m_selection_rectangle.startWorld = minWorldPoint;
					m_selection_rectangle.endWorld = maxWorldPoint;
				}
				for (var i = 0; i < arrayLength; i++) {
					
				    //m_camera_list[i].material.opacity = 0.1; 
				    var scoreCam = getScoreCam(i, intersectsCamera, usingSelectionRectangle)
				    var elem = {
					    'index': i,
					    'score': scoreCam,
					    'collection_index': -1,
					};
					//console.log(m_camera_list[i].name+" "+i + " score: "+ scoreCam)
					if(isNaN(elem.score) )
						elem.score = 0;
					
					if(i >= m_current_candidates.length)
					{
						m_current_candidates.push(elem)
					}
				    else
				    {
				    	m_current_candidates[i] = elem
				    }
	
						
					
				}
				m_current_candidates.sort(compareCandidates)
				normalizeScores()
				updateCandidateCollections()
				if(m_current_capture_in_view_index == -1)
				{
					changeCaptureInView(m_current_candidates[0].index)
				}
				showCollections()
				//showCaptures(true)
				console.log("INFO: Updating candidates: DONE")
			}
			
			/*function changeMode()
			{
				if(m_camera_mode == "FLY")
					m_camera_mode = "ORBIT"
				else if(m_camera_mode == "ORBIT")
					m_camera_mode = "TRACK"
				else if(m_camera_mode == "TRACK")
					m_camera_mode = "FLY"
				else
					m_camera_mode = "FLY"
				initControls(m_camera_mode)
			}*/
			function initControls(mode)
			{
				m_camera_capture_orto = new THREE.OrthographicCamera( -0.03,0.03, 0.03, -0.03, 0.01, 1);

				m_camera_collections = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0, 10);
				m_scene_collections.add(m_camera_collections);


				var start_x = m_models_values[m_gui_options.current_model].pos_x_cam_start
				var start_y = m_models_values[m_gui_options.current_model].pos_y_cam_start
				var start_z = m_models_values[m_gui_options.current_model].pos_z_cam_start

				m_camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.01, 10 );
				m_camera.position.set( start_x,start_y,start_z );
				//camera.position.set( 3,0.15,3 );
				m_camera.name = "main_camera"
				m_camera.up.set(0,0,1);

				m_camera_capture = new THREE.PerspectiveCamera( 50.5, 4000 / 2950, 0.01, 10 );
				m_camera_capture.position.set( start_x,start_y,start_z );
				m_cameraHelper = new THREE.CameraHelper(m_camera_capture);
				m_scene.add(m_cameraHelper);
				//camera.position.set( 3,0.15,3 );
				
				m_camera_capture.up.set(0,0,1);
				m_camera_capture_orto.up.set(0,0,1);


				if(mode == "FLY")
				{
					m_controls = new FlyControls( m_camera, m_renderer.domElement );
					m_controls.movementSpeed = 10;
					m_controls.domElement = m_renderer.domElement;
					m_controls.rollSpeed = Math.PI / 12;
					m_controls.autoForward = false;
					m_controls.dragToLook = false;
				}
				else if(mode == "ORBIT")
				{

					m_controls = new OrbitControls( m_camera, m_renderer.domElement );
					m_controls.minPolarAngle =  - Infinity; // radians
					m_controls.maxPolarAngle = Infinity; // radians
					m_controls.minDistance = 0;
					m_controls.maxDistance = 3;
					m_controls.minAzimuthAngle = - Infinity; // radians
					m_controls.maxAzimuthAngle = Infinity; // radians

					m_controls.target.set(-1*0.03,start_y,2*0.03)

					/*
					m_controls_secondary = new OrbitControls( m_camera_capture_orto, m_renderer.domElement );
					m_controls_secondary.minPolarAngle =  - Infinity; // radians
					m_controls_secondary.maxPolarAngle = Infinity; // radians
					m_controls_secondary.minDistance = 0;
					m_controls_secondary.maxDistance = 3;
					m_controls_secondary.minAzimuthAngle = - Infinity; // radians
					m_controls_secondary.maxAzimuthAngle = Infinity; // radians
					m_controls_secondary.target.set(-1*0.03,start_y,2*0.03);
					m_controls_secondary.enabled = false;*/

				}
				else if(mode == "TRACK")
				{
					m_controls = new TrackballControls( m_camera, m_renderer.domElement );
					m_controls.rotateSpeed = 1.0;
					m_controls.zoomSpeed = 0.6;
					m_controls.panSpeed = 0.2;

					m_controls.keys = [ 65, 83, 68 ];
					m_controls.target.set(-1*0.03,-20*0.03,2*0.03)
				}
				else
				{
					console.log("ERROR, mode "+mode+ " not found");
				}
			}

			function clearSceneData()
			{
				//APL STATE
				m_application_state.state = AppStates.THREE_JS_INIT;
				m_application_state.num_cameras_loaded = 0;
				m_application_state.num_models_loaded = 0;
				m_application_state.three_js_inited = false;
				m_application_state.num_cameras_to_load = 0;
				m_application_state.num_models_to_load = 0;
				m_application_state.precomputed_file_loaded = false;
				m_application_state.precomputation_done = false;
				m_application_state.textures_loaded = false;
				m_application_state.count_precomputation_iterations = 0;
				m_application_state.capture_index_over_mouse = -1;
				m_application_state.transition_animation_step = 1.0;
				m_application_state.views_swaped = false;
				m_application_state.select_controls_enabled = false;
				m_application_state.need_to_update_auto_detect = false;

				

				m_min_pos = null;
				m_max_pos = null;

				m_has_any_secondary_capture = false;
				m_plane_image_secondary = null;
				m_render_target_secondary = null;

				m_camera_list = [];
				m_camera_mesh_list = [];
				m_scene_models = [];
				m_current_candidates = [];
				m_current_candidates_collections = [];

				m_timer_update = 0;
				m_cams_enabled = false;
				m_current_capture_in_view_index = -1;
				m_capture_rays_need_recomputation = true;

				m_dragging = false;
				m_current_sprites_in_scene = [];

				while(m_scene.children.length > 0){ 
				    m_scene.remove(m_scene.children[0]); 
				}
				while(m_scene_collections.children.length > 0){ 
				    m_scene_collections.remove(m_scene_collections.children[0]); 
				}

			}
			function startSceneForModel()
			{

				clearSceneData()
				document.getElementById("loadingTextContainer").style.visibility = "visible";
				var xmlhttp = new XMLHttpRequest();
				xmlhttp.onreadystatechange = function() {
				    if (this.readyState == 4 && this.status == 200) {
				        var myObj = JSON.parse(this.responseText);
				        console.log("INFO: Capture info json loading... DONE")
				        loadCameras(myObj)
				        setDefaultColorsCameras();
				    }
				};
				xmlhttp.open("GET", 'models/'+m_models_values[m_gui_options.current_model].path+"/capture_info/cameraInfo.json", true);
				console.log("INFO: Capture info json loading...")
				xmlhttp.send();

				loadModels();
				initControls(m_camera_mode)

				

				m_application_state.three_js_inited = true
				animate();
			}
			function init() {

				
				m_container = document.createElement( 'div' );
				//const canvas = document.getElementById( 'canvas' );
				//canvas.width = 300 * window.devicePixelRatio;
				//canvas.height = 300 * window.devicePixelRatio;
				//const context = canvas.getContext( '2d' );
				document.body.appendChild( m_container );

				m_scene = new THREE.Scene();
				m_scene.background = new THREE.Color( 0x72645b );
				m_scene.fog = new THREE.Fog( 0x72645b, 2, 15 );

				m_scene_collections = new THREE.Scene();
				m_scene_collections.background = null;


				// m_renderer
				var canvas = document.getElementById("canvas");
				m_renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
				m_renderer.setPixelRatio( window.devicePixelRatio );
				m_renderer.setSize( window.innerWidth, window.innerHeight );
				m_renderer.outputEncoding = THREE.sRGBEncoding;
				m_renderer.setClearColor(0xffffff, 0);
				m_renderer.shadowMap.enabled = true;
				m_renderer.autoClear = false; 


				

				m_container.appendChild( m_renderer.domElement );

				// stats

				m_stats = new Stats();
				m_container.appendChild( m_stats.dom );
				document.body.appendChild( VRButton.createButton( m_renderer ) );
				m_renderer.xr.enabled = true;

				createGUI();

				m_selection_rectangle.selectionBox = new SelectionBox( m_camera, m_scene );
				m_selection_rectangle.helper = new SelectionHelper( m_selection_rectangle.selectionBox, m_renderer, 'selectBox' );
				m_selection_rectangle.helper.element.hidden = true;

				window.addEventListener( 'resize', onWindowResize );
				
				document.addEventListener( 'mousewheel', onDocumentMouseWheel );
				document.addEventListener( 'pointerup', onDocumentPointerUp );
				document.addEventListener('pointermove', onDocumentPointerMove)
				document.addEventListener( 'pointerdown', onDocumentPointerDown );
				document.addEventListener("keydown", onDocumentKeyDown, false);
				document.addEventListener("keyup", event => {
				  if (/*event.isComposing || */event.keyCode === 17 && !m_application_state.views_swaped) {
				    m_application_state.select_controls_enabled = false;
					m_dragging = false

				    m_controls.enabled = true;

				    m_selection_rectangle.helper.element.hidden = true;
					/*m_canvas.setHeight(0);
					m_canvas.setWidth(0);*/
				  }
				});

				m_manager.onLoad = function()
				{
					//m_renderer.render( m_scene, camera );
				    console.log("INFO: DOMA_TEXTURE_LOADED");
				    animate()
				    
					m_application_state.textures_loaded = true
				}

				startSceneForModel();
				
			}

			function addShadowedLight( x, y, z, color, intensity ) {

				const directionalLight = new THREE.DirectionalLight( color, intensity );
				directionalLight.position.set( x, y, z );
				m_scene.add( directionalLight );

				directionalLight.castShadow = true;

				const d = 1;
				directionalLight.shadow.camera.left = - d;
				directionalLight.shadow.camera.right = d;
				directionalLight.shadow.camera.top = d;
				directionalLight.shadow.camera.bottom = - d;

				directionalLight.shadow.camera.near = 1;
				directionalLight.shadow.camera.far = 4;

				directionalLight.shadow.mapSize.width = 1024;
				directionalLight.shadow.mapSize.height = 1024;

				directionalLight.shadow.bias = - 0.001;

			}



			function onWindowResize() {

				m_camera.aspect = window.innerWidth / window.innerHeight;
				m_camera.updateProjectionMatrix();

				m_renderer.setSize( window.innerWidth, window.innerHeight );



				m_camera_collections.left = window.innerWidth / - 2;
				m_camera_collections.right =window.innerWidth / 2;
				m_camera_collections.top = window.innerHeight / 2;
				m_camera_collections.bottom = window.innerHeight / - 2;
				m_camera_collections.updateProjectionMatrix();
				showCollections()


				//m_camera_capture.aspect = window.innerWidth / window.innerHeight;
				/*m_camera_capture_orto.left = window.innerWidth / - 2;
				m_camera_capture_orto.right =window.innerWidth / 2;
				m_camera_capture_orto.top = window.innerHeight / 2;
				m_camera_capture_orto.bottom = window.innerHeight / - 2;
				m_camera_capture_orto.updateProjectionMatrix();*/
				m_camera_capture_orto.updateProjectionMatrix();

				//m_camera_capture.updateProjectionMatrix();
				//m_captureShader.uniforms.resolution.value.set( window.innerWidth, window.innerWidth );
				/*if(m_application_state.select_controls_enabled)
				{
					m_canvas.setHeight(window.innerHeight);
				    m_canvas.setWidth(window.innerWidth);
				}
				else {
					m_canvas.setHeight(0);
			    	m_canvas.setWidth(0);
				}

			    m_canvas.renderAll();*/

			}

			function animate() {
				const timer = Date.now() * 0.0005;
				const delta = m_clock.getDelta();
				requestAnimationFrame( animate );

				switch(m_application_state.state)
				{
					case AppStates.READY_TO_GO:
					{
						updateCollectionsAnims(delta)
						if(m_application_state.need_to_update_auto_detect)
							m_timer_update += delta

						if(m_old_pos_cam.distanceTo(m_camera.position) > 0.0001)
						{
							//console.log("changed!! " + m_old_pos_cam.x + " " +m_camera.position.x)
							m_timer_update = 0;
							m_application_state.need_to_update_auto_detect = true;
						}
							
						
						if(m_camera_mode != "FLY")
						{
							m_controls.update();
							//m_controls_secondary.update();
						}
							
						m_stats.update();
						if(m_timer_update > m_gui_options.timer_recalc)
						{
							//console.log("update")
							m_application_state.need_to_update_auto_detect = false
							m_timer_update = 0
							if(m_gui_options.auto_score_enabled)
								updateCandidates(false);
						}
						if(m_camera_mode == "FLY")
						{
							m_controls.movementSpeed = 0.33 * 1;
							m_controls.update( delta );
						}
						m_old_pos_cam.copy(m_camera.position);

						m_scene_models[0].material.uniforms.showRedArea.value = m_gui_options.red_area_enabled;
						break
					}


					case AppStates.THREE_JS_INIT:
					{
						if(m_application_state.three_js_inited)
						{
							m_application_state.state = AppStates.LOADING_MESHES
						}
						break
					}
					case AppStates.LOADING_MESHES:
					{
						if(m_application_state.num_models_to_load == m_application_state.num_models_to_load && m_application_state.num_cameras_loaded == m_application_state.num_cameras_to_load)
						{
							document.getElementById("loadingText").innerHTML = "Loading: 80%";
							m_application_state.state = AppStates.LOADING_TEXTURES
						}
						break
					}
					case AppStates.LOADING_TEXTURES:
					{
						if(m_application_state.textures_loaded)
						{

							m_application_state.state = AppStates.LOADING_PRECOMPUTED_DATA
							var loader = new THREE.FileLoader();
					        loader.load('models/'+m_models_values[m_gui_options.current_model].path+'/capture_info/precomputedCameraData.txt', function ( data ) {
							        // output the text to the console
							        loadPrecomputedFile(data)
							        m_application_state.precomputed_file_loaded = true
									document.getElementById("loadingText").innerHTML = "Loading: 90%";
							});
							
						}
						break
					}
					case AppStates.LOADING_PRECOMPUTED_DATA:
					{
						if(m_application_state.precomputed_file_loaded)
						{
							if(m_capture_rays_need_recomputation)
							{
								
								precomputeCaptureInfo(m_num_rays_precomputation,m_num_rays_precomputation,m_application_state.count_precomputation_iterations)
							}
							else
							{
								m_application_state.state = AppStates.READY_TO_GO
								document.getElementById("loadingText").innerHTML = "";
								document.getElementById("loadingTextContainer").style.visibility = "hidden";
								console.log("INFO: System ready to go!")
							}
							
						}
							
						break
					}
				}

				
				render();


			}
			function renderMainCamera(view_index, draw_border)
			{
				if(m_plane_image_secondary != null)
					m_plane_image_secondary.material.uniforms.showTexture.value = m_gui_options.show_photo_enabled && m_gui_options.show_view_enabled && m_gui_options.show_camera_enabled;
				const left = Math.floor( window.innerWidth * m_views[view_index].left );
				const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
				const width = Math.floor( window.innerWidth * m_views[view_index].width );
				const height = Math.floor( window.innerHeight * m_views[view_index].height );

				m_renderer.setViewport( left, bottom, width, height );
				m_renderer.setScissor( left, bottom, width, height );
				m_renderer.setScissorTest( true );
				

				if(draw_border)
				{
					m_renderer.setClearColor ( new THREE.Color(0x000000), 1.0 )
					m_renderer.clear();
					m_renderer.setViewport( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
					m_renderer.setScissor( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
				}
				m_camera.aspect = width / height;
				m_camera.updateProjectionMatrix();
				m_cameraHelper.visible = m_gui_options.show_camera_enabled;
				m_renderer.render( m_scene, m_camera );
			}
			function renderSecondaryCamera(view_index, draw_border)
			{

				if(m_plane_image_secondary != null)
					m_plane_image_secondary.material.uniforms.showTexture.value = m_gui_options.show_photo_enabled;
				const left = Math.floor( window.innerWidth * m_views[view_index].left );
				const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
				const width = Math.floor( window.innerWidth * m_views[view_index].width );
				const height = Math.floor( window.innerHeight * m_views[view_index].height );

				if(draw_border)
				{
					m_renderer.setViewport( left-0.1, bottom, width+0.1, height+0.1 );
					m_renderer.setScissor( left-0.1, bottom, width+0.1, height+0.1 );
					m_renderer.setScissorTest( true );
				}
				m_renderer.setViewport( left, bottom, width, height );
				m_renderer.setScissor( left, bottom, width, height );
				m_renderer.setScissorTest( true );
				

				if(draw_border)
				{
					m_renderer.setClearColor ( new THREE.Color(0x000000), 1.0 )
					m_renderer.clear();
					m_renderer.setViewport( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
					m_renderer.setScissor( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
				}
				m_camera_capture.aspect = width / height;
				m_camera_capture.updateProjectionMatrix();
				m_cameraHelper.visible = false;

				var frustumHeight = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
				var frustumWidth = frustumHeight * m_camera_capture.aspect;
				m_plane_image_secondary.scale.x = frustumWidth;
				m_plane_image_secondary.scale.y = frustumHeight;

				m_renderer.render( m_scene, m_camera_capture );
			}
			function renderClusters(view_index)
			{
				m_renderer.clearDepth();
				const left = Math.floor( window.innerWidth * m_views[view_index].left );
				const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
				const width = Math.floor( window.innerWidth * m_views[view_index].width );
				const height = Math.floor( window.innerHeight * m_views[view_index].height );

				m_renderer.setViewport( left, bottom, width, height );
				m_renderer.setScissor( left, bottom, width, height );
				m_renderer.render( m_scene_collections, m_camera_collections );
			}
			function render() {
				//if ( windowWidth != window.innerWidth || windowHeight != window.innerHeight ) {

				//	windowWidth = window.innerWidth;
				//	windowHeight = window.innerHeight;

				m_renderer.setSize( window.innerWidth, window.innerHeight );

				//}
				m_cameraHelper.update();
				m_renderer.clear();
				if(m_scene_models.length >0)
					m_scene_models[0].material.uniforms.projectCapture.value = m_gui_options.project_capture_enabled && m_plane_image_secondary != null;
				if(m_gui_options.show_view_enabled && !m_application_state.select_controls_enabled)
				{
					if(m_application_state.views_swaped)
					{
						renderSecondaryCamera(0, false);
						renderMainCamera(1, true);
					}
					else
					{
						renderMainCamera(0, false);
						renderSecondaryCamera(1, true);
					}
				}
				else
				{
					if(m_application_state.views_swaped)
					{
						renderSecondaryCamera(2, false);
					}
					else
					{
						renderMainCamera(2, false);
					}
				}

				if(!m_application_state.select_controls_enabled)
					renderClusters(2);
				

			}
			function precomputeCaptureInfo(rays_x, rays_y, iteration)
			{
				

				precomputeRays(rays_x, rays_y, iteration);
				m_application_state.count_precomputation_iterations = m_application_state.count_precomputation_iterations +1
				if(m_application_state.count_precomputation_iterations == m_camera_list.length)
				{
					m_capture_rays_need_recomputation = false
					precomputeCaptureSimilitude();
					savePrecomputedFile()
					m_application_state.precomputation_done = true
					m_application_state.count_precomputation_iterations = 0
				}
				
				
			}
			function precomputeRays(rays_x, rays_y, i)
			{
				console.log("INFO: precomputing rays...")
				//for (var i = 0; i < m_camera_list.length; i++) 
				{
					m_camera_list[i].camera.updateProjectionMatrix()
					m_camera_list[i].rays = []
					for(var x = 0; x <= 1; x +=(1/(rays_x-1)))
					{
						for(var y = 0; y <= 1; y +=(1/(rays_y-1)))
						{

							var NDC_position = new THREE.Vector2(x*2-1,y*2-1); 
							var point = getWorldIntersectFromNDCxy(m_camera_list[i].camera, NDC_position, m_scene_models);
							if(point !=null)
								m_camera_list[i].rays.push(point);
							/*
							var NDC_position = new THREE.Vector3(x*2-1,y*2-1,1);
							var pointIntersect = new THREE.Vector3();
							NDC_position.unproject(m_camera_list[i].camera);
							var test_ray = new THREE.Vector3();

							//m_camera_list[i].getWorldDirection( directionPhoto );
							var raycasterPhoto =  new THREE.Raycaster(m_camera_list[i].mesh.position, NDC_position); 

							var intersectsPhoto = raycasterPhoto.intersectObjects( m_scene_models );  
							//console.log(intersectsPhoto)
							if(intersectsPhoto.length > 0)
							{
								pointIntersect.copy(intersectsPhoto[0].point)
								m_camera_list[i].rays.push(pointIntersect)
							}*/
						}
					}
					var completation = Math.floor((i/m_camera_list.length)*90)

					document.getElementById("loadingText").innerHTML = "Precomputing rays: "+completation.toString() +"%";

					console.log("      finished precomputing capture positions for cam: "+i+" , rays found: "+m_camera_list[i].rays.length)
				}
				
				console.log("INFO: finished precomputing rays")
				
			}
			function computeSimilitudeForCams(cam1, cam2)
			{
				
				var count_inside_rays_cam1 = 0
				var count_inside_rays_cam2 = 0
				var rate_cam1 = 0;
				var rate_cam2 = 0;
				for(var index_ray = 0; index_ray <cam1.rays.length; ++index_ray)
				{
					var projected = getNDCposFromWorld(cam2.camera, cam1.rays[index_ray])
					/*var projected = new THREE.Vector3();
					projected.copy(cam1.rays[index_ray])
					projected.project(cam2.camera)
					//console.log(projected)*/
					if(projected.x > -1.0 && projected.x < 1.0 && projected.y > -1.0 && projected.y < 1.0)
					{
						//console.log("added " + index_cam)
						count_inside_rays_cam1 = count_inside_rays_cam1 +1
					}
						
				}
				if(cam1.rays.length > 0)
					rate_cam1 = count_inside_rays_cam1/cam1.rays.length;

				for(var index_ray = 0; index_ray <cam2.rays.length; ++index_ray)
				{
					var projected = new THREE.Vector3();
					projected.copy(cam2.rays[index_ray])
					projected.project(cam1.camera)
					//console.log(projected)
					if(projected.x > -1.0 && projected.x < 1.0 && projected.y > -1.0 && projected.y < 1.0)
					{
						//console.log("added " + index_cam)
						count_inside_rays_cam2 = count_inside_rays_cam2 +1
					}
						
				}
				if(cam2.rays.length > 0)
					rate_cam2 = count_inside_rays_cam2/cam2.rays.length;

				return (rate_cam1+rate_cam2)/2
			}
			function computeSimilitudesIndicesOrdered()
			{
				for(var index_cam=0; index_cam < m_camera_list.length; ++index_cam)
				{	
					m_camera_list[index_cam].similitudes_indices_ordered = []
					for(var index_cam2=0; index_cam2 < m_camera_list[index_cam].similitudes.length; ++index_cam2)
					{
						var curr_sim = 
						{
							index: index_cam2,
							similitude: m_camera_list[index_cam].similitudes[index_cam2]
						}
						m_camera_list[index_cam].similitudes_indices_ordered.push(curr_sim)
					}
					m_camera_list[index_cam].similitudes_indices_ordered.sort(compareSimilitudes)
				}
			}
			function precomputeCaptureSimilitude()
			{
				console.log("INFO: Precomputing Similitudes....")
				for(var index_cam=0; index_cam < m_camera_list.length; ++index_cam)
				{	
					m_camera_list[index_cam].similitudes = []
					for(var index_cam2=0; index_cam2 < m_camera_list.length; ++index_cam2)
					{
						m_camera_list[index_cam].similitudes.push(computeSimilitudeForCams(m_camera_list[index_cam],m_camera_list[index_cam2]))
					}
					//var completation = Math.floor((index_cam/m_camera_list.length)*50+50)

					//document.getElementById("loadingText").innerHTML = "Precomputed rays not found, precomputing again: "+completation.toString() +"%";
				}
				computeSimilitudesIndicesOrdered()
				console.log("INFO: Precomputing Similitudes: DONE")
			}

			function loadPrecomputedFile(data)
			{
				console.log("INFO: Loading Precomputed File...")
				var data_cameras = data.split('\n');
				if(data_cameras.length != m_camera_list.length)
				{
					m_capture_rays_need_recomputation = true
					console.log("INFO: Precomputed File outdated, need to recompute")
					return
				}
				else
				{
					for(var index_cam=0; index_cam < data_cameras.length; ++index_cam)
					{
						m_camera_list[index_cam].rays = []
						var data_camera = data_cameras[index_cam].split(' ')
						while(data_camera[0] == "")
							data_camera.shift()
						var num_rays = data_camera[0]

						for(var ray = 0; ray < num_rays; ++ray)
						{
							var x = data_camera[ray*3+1]
							var y = data_camera[ray*3+1+1]
							var z = data_camera[ray*3+1+2]
							var position_ray = new THREE.Vector3(x,y,z);
							m_camera_list[index_cam].rays.push(position_ray);
						}
						m_camera_list[index_cam].similitudes = []
						for(var simil_cam_index = 0; simil_cam_index <m_camera_list.length; ++simil_cam_index)
						{
							var simil = data_camera[num_rays*3+1+simil_cam_index]
							m_camera_list[index_cam].similitudes.push(simil)
						}
					}
					m_capture_rays_need_recomputation = false
					computeSimilitudesIndicesOrdered()
				}
				console.log("INFO: Loading Precomputed File: DONE")

				
				
					
			}
			function savePrecomputedFile()
			{
				console.log("INFO: Saving Precomputed File...")
            	var parts = []
				for(var index_cam=0; index_cam < m_camera_list.length; ++index_cam)
				{	

					parts.push(m_camera_list[index_cam].rays.length);

					for(var index_ray=0; index_ray < m_camera_list[index_cam].rays.length; ++index_ray)
					{
						var raypos = m_camera_list[index_cam].rays[index_ray]
						parts.push(" " + raypos.x + " " + raypos.y + " " + raypos.z);
					}
					for(var index_sim=0; index_sim < m_camera_list[index_cam].similitudes.length; ++index_sim)
					{
						var sim = m_camera_list[index_cam].similitudes[index_sim]
						parts.push(" " + sim);
					}
					if(index_cam < m_camera_list.length -1)
						parts.push("\n");
				}
				var blob = new Blob(parts);
				saveAs(blob, 'precomputedCameraData.txt')
				console.log("INFO: Saving Precomputed File: DONE")
			}

			

		</script>
	</body>
</html>
