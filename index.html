<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - PLY</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div style="position: absolute; text-align: center; width: 100%;">
			<!--<img id="captureImage" src="images/0001.jpg" style="visibility:hidden" alt="Image" height="200">-->
			<img id="captureImage5" src="images/0001.jpg" alt="Image" height="50" align="top" onclick="moveCamToImage(5)">
			<img id="captureImage3" src="images/0001.jpg" alt="Image" height="100" align="top" onclick="moveCamToImage(3)">
			<img id="captureImage1" src="images/0001.jpg" alt="Image" height="150" align="top" onclick="moveCamToImage(1)">
			<img id="captureImage0" src="images/0001.jpg" alt="Image" height="200" align="top" onclick="moveCamToImage(0)">
			<img id="captureImage2" src="images/0001.jpg" alt="Image" height="150" align="top" onclick="moveCamToImage(2)">
			<img id="captureImage4" src="images/0001.jpg" alt="Image" height="100" align="top" onclick="moveCamToImage(4)">
			<img id="captureImage6" src="images/0001.jpg" alt="Image" height="50" align="top" onclick="moveCamToImage(6)">
		</div>
		<script src="scripts/shaders.js"></script>
		<script>
			
		</script>
		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { PLYLoader } from './jsm/loaders/PLYLoader.js';

			import { OrbitControls } from './jsm/controls/CustomOrbitControls.js';
			import { FlyControls } from './jsm/controls/FlyControls.js';
			import { TrackballControls } from './jsm/controls/CustomTrackballControls.js';
			let container, stats, gui;

			let camera, scene , renderer;

			const clock = new THREE.Clock();
			var cameraList = [];
			var scene_models = [];
			var captureNames = [];
			var captureRays = [];
			var aux_index = 0;
			var current_candidates = [];
			var manager = new THREE.LoadingManager();
			var controls;
			var camera_mode = "ORBIT";
			var timer_update = 0;
			var cams_enabled = true;
			var need_to_update = true;
			var old_pos_cam =  new THREE.Vector3();
			init();
			animate();

			document.body.appendChild( renderer.domElement );
			document.addEventListener( 'pointerup', onDocumentMouseDown );
			document.addEventListener("keydown", onDocumentKeyDown, false);

			document.getElementById("captureImage6").onclick = function() {moveCamToImage(6);}
			document.getElementById("captureImage5").onclick = function() {moveCamToImage(5);}
			document.getElementById("captureImage4").onclick = function() {moveCamToImage(4);}
			document.getElementById("captureImage3").onclick = function() {moveCamToImage(3);}
			document.getElementById("captureImage2").onclick = function() {moveCamToImage(2);}
			document.getElementById("captureImage1").onclick = function() {moveCamToImage(1);}
			document.getElementById("captureImage0").onclick = function() {moveCamToImage(0);}

			manager.onLoad = function()
			{
				//renderer.render( scene, camera );
			    console.log("LOADDDED");
				precomputeRays()

			}
			function createGUI()
			{
				
			}
			function moveCamToImage(index_candidate)
			{
				var captureCam = cameraList[current_candidates[index_candidate].index]
				var direction = new THREE.Vector3();
				captureCam.getWorldDirection( direction );
				//controls.enabled = false;
				//camera.position.copy( intersects[ 0 ].object.position )
				camera.position.copy( captureCam.position ).add( direction.multiplyScalar( 0.09 ) );
				
				//camera.quaternion.copy( intersects[ 0 ].object.quaternion );

				var v1 = new THREE.Vector3(); // create once and reuse it

				//v1.copy( captureCam.up ).applyQuaternion( captureCam.quaternion );
				//camera.up.set(v1.x, v1.y, v1.z); 
				//camera.lookAt(intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z)
				controls.update()
				//controls.update()
				//controls.coupleCenters = true;
				
				controls.target = new THREE.Vector3( captureCam.position.x, captureCam.position.y, captureCam.position.z );
				//controls.target.copy(v1.x, v1.y, v1.z)
				//controls.target.add( direction.multiplyScalar( 0.5 ) );
				controls.update()
			}
			function showCapture(indexCapture)
			{
				/*if(indexCapture != -1)
				{
					var source = "images/"+captureNames[indexCapture]

					document.getElementById('captureImage').src= source
					document.getElementById("captureImage").style.visibility = "visible";

					console.log(source)
				}*/
			}

			function showCaptures(changed)
			{
				if(changed)
				{
					var arrayLength = cameraList.length;

					for (var i = 0; i < 7; i++) {
						var candidate = current_candidates[i]
						if(candidate)
						{
						    var source = "images/"+captureNames[candidate.index]

							document.getElementById('captureImage'+i).src= source
							document.getElementById("captureImage"+i).style.visibility = "visible";
						}
						

					}	
					//console.log(current_candidates)
				}
				

				/*if(indexCapture != -1)
				{
					var source = "images/"+captureNames[indexCapture]

					document.getElementById('captureImage').src= source
					document.getElementById("captureImage").style.visibility = "visible";

					console.log(source)
				}*/
			}


			function onDocumentKeyDown(event) {
			    var keyCode = event.which;
			    if (keyCode == 82) { //R
			        resetCamera();
			    } else if (keyCode == 77) { //M
			        changeMode();
			    }  else if (keyCode == 72) { //M
			        toggleEnableCams();
			    }  
			    
			};
			
			function onDocumentMouseDown( event ) {   
				if(!cams_enabled)
					return;
				if(camera_mode == "FLY")
					return;
				//console.log(camera_mode)
	            event.preventDefault();
	            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );     
	            var raycaster =  new THREE.Raycaster();                                        
	           raycaster.setFromCamera( mouse3D, camera );
	            var intersects = raycaster.intersectObjects( cameraList );
				//console.log(intersects)
				setDefaultColorsCameras();
	            if ( intersects.length > 0 ) {
	            	var photoIndex = -1;
	            	for (var i = 0; i < cameraList.length; i++) {
					    if(intersects[ 0 ].object.id == cameraList[i].id)
					    	photoIndex = i;
					}
					//console.log(photoIndex);
					//console.log(cameraList)
					//console.log(captureNames)
					//controls.coupleCenters = false;
					//showCapture(photoIndex);
	                intersects[ 0 ].object.material.color.setHex( 0x0000ff );
	                intersects[ 0 ].object.material.opacity = 0.3; 
	                var direction = new THREE.Vector3();
					intersects[ 0 ].object.getWorldDirection( direction );
					//controls.enabled = false;
					//camera.position.copy( intersects[ 0 ].object.position )
					camera.position.copy( intersects[ 0 ].object.position ).add( direction.multiplyScalar( 0.09 ) );
					
					//camera.quaternion.copy( intersects[ 0 ].object.quaternion );

					var v1 = new THREE.Vector3(); // create once and reuse it

					v1.copy( intersects[ 0 ].object.up ).applyQuaternion( intersects[ 0 ].object.quaternion );
					camera.up.set(v1.x, v1.y, v1.z); 
					//camera.lookAt(intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z)
					controls.update()
					//controls.update()
					//controls.coupleCenters = true;
					
					controls.target = new THREE.Vector3( intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z );
					//controls.target.copy(v1.x, v1.y, v1.z)
					//controls.target.add( direction.multiplyScalar( 0.5 ) );
					controls.update()
					

	            }
	            else
	            {
	            	//document.getElementById("captureImage").style.visibility = "hidden";
	            	//console.log(camera)
	            	//console.log(controls)
	            }
	        }
	        function setDefaultColorsCameras()
	        {

	        	var arrayLength = cameraList.length;
				for (var i = 0; i < arrayLength; i++) {
				    cameraList[i].material.color.setHex( 0xffffff );
				    cameraList[i].material.opacity = 0.1; 
				    //Do something
				}
	        }
			function loadCamera(element, index, array)
			{

				if(!captureNames[aux_index] || captureNames[aux_index].startsWith("Scan"))
				{
					captureNames.splice(aux_index, 1); 
					return;
				}
				aux_index = aux_index +1;
				 var m = new THREE.Matrix4();

				 m.set( element.m1, element.m2, element.m3, element.tx,
		           element.m4, element.m5, element.m6, element.ty,
		           element.m7, element.m8, element.m9, element.tz,
		           0, 0, 0, 1 );
				m.invert();

				 //var t = new THREE.Vector3(element.tx, element.ty, element.tz);
				 //var dir = new THREE.Vector3(0, 0, -1);
				 //dir.applyMatrix3(m);
				 //console.log(captureNames[aux_index-1])
				 //console.log(t)
				 //console.log(t);
				 //t.applyMatrix3(m);
				 //console.log(t);



				 const loader = new PLYLoader();
				 loader.load( './models/ply/ascii/camera.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					const edges = new THREE.EdgesGeometry( geometry );
					//const material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
					const material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
					material.transparent = true;
					material.opacity = 0.1; 
					//const mesh = new THREE.LineSegments( geometry, material );
					//const mesh = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } ) );
					const mesh = new THREE.Mesh( geometry, material );
					//mesh.rotation.x = dir.x;
					//mesh.rotation.y = dir.y;
					//mesh.rotation.z = dir.z;
					//var rotation = new THREE.Matrix4();
					//mesh.applyMatrix(R);

					//mesh.lookAt(dir)


					//var rotation2 = new THREE.Matrix4().makeRotationZ(Math.PI/2);
					//var rotation2 = new THREE.Matrix4();
					//var translation = new THREE.Matrix4().makeTranslation(t.x*0.03, t.y*0.03, t.z*0.03);
					//var transformation = translation.multiply(rotation2);

					mesh.applyMatrix(m);
					mesh.applyMatrix4(new THREE.Matrix4().makeScale(0.03, 0.03, 0.03))
					mesh.castShadow = false;
					mesh.receiveShadow = false;
					scene.add( mesh );
					cameraList.push(mesh);

					

					
						

					setDefaultColorsCameras()
					console.log("CAMERA LOADED")

				} );

			}
			function precomputeRays()
			{
				for (var i = 0; i < cameraList.length; i++) {
					var directionPhoto = new THREE.Vector3();
					var pointIntersect = new THREE.Vector3();
					cameraList[i].getWorldDirection( directionPhoto );
					var raycasterPhoto =  new THREE.Raycaster(cameraList[i].position, directionPhoto); 

					var intersectsPhoto = raycasterPhoto.intersectObjects( scene_models );  
					console.log(intersectsPhoto)
					if(intersectsPhoto.length == 0)
						captureRays.push(null)
					else
					{
						pointIntersect.copy(intersectsPhoto[0].point)
						captureRays.push(pointIntersect)
					}
				}
			}
			function loadCameras(cameras) {
				cameras.cameras.forEach(loadCamera);
			}
			
			function loadDoma()
			{
				const loader = new PLYLoader();
				const loaderTex = new THREE.TextureLoader(manager);

				loader.load( './models/ply/ascii/doma-interior_textured.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					let uniforms = {
				        colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
				        colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)},
				        capturePos: {type: 'vec3', value: new THREE.Vector3(0,0,0)},
				        modelViewMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        projectionMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: loaderTex.load('./models/textures/doma-interior_texture16k.jpg') }
				    }
					const material = new THREE.ShaderMaterial( { 
						uniforms: uniforms,
					    fragmentShader: fragmentShader(),
					    vertexShader: vertexShader(),
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );
					const mesh = new THREE.Mesh( geometry, material );
					mesh.scale.multiplyScalar( 0.03 );
					//mesh.rotation.x = - Math.PI / 2;
					mesh.position.x = 0.0;
					mesh.position.y = 0.0;
					mesh.position.z = 0.0;
					
					 

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					scene.add( mesh );
					scene_models.push(mesh);

					//TODO Check cams loaded
					console.log("MODEL LOADED")
					//precomputeRays()

				} );

				
			}
			function loadModels()
			{

				loadDoma();

				scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

				addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 );


			}
			function resetCamera()
			{
				initControls(camera_mode)
			}
			function toggleEnableCams()
			{
				cams_enabled = !cams_enabled;
				var arrayLength = cameraList.length;
				if(cams_enabled)
				{
					for (var i = 0; i < arrayLength; i++) {
					    cameraList[i].material.opacity = 0.1; 
					}
				}
				else
				{
					for (var i = 0; i < arrayLength; i++) {
					    cameraList[i].material.opacity = 0.0; 
					}
				}
			}
			function getScorePosition(index_cam)
			{
				var dist = cameraList[index_cam].position.distanceTo(camera.position)
				return dist;
				
			}
			function getScoreRotation(index_cam)
			{
				var direction1 = new THREE.Vector3();
				var direction2 = new THREE.Vector3();
				cameraList[index_cam].getWorldDirection( direction1 );
				camera.getWorldDirection( direction2 );
				var dist = direction1.distanceTo(direction2);
				return 2 - dist;
				
			}
			function getScoreRays(index_cam, intersectsCamera)
			{
				if(intersectsCamera.length == 0)
					return 1;
				/*var directionPhoto = new THREE.Vector3();
				cameraList[index_cam].getWorldDirection( directionPhoto );
				var raycasterPhoto =  new THREE.Raycaster(cameraList[index_cam].position, directionPhoto); 

				var intersectsPhoto = raycasterPhoto.intersectObjects( scene_models );  

				if(intersectsPhoto.length == 0)
					return 1;*/
				camera.updateProjectionMatrix();
				//console.log(intersectsPhoto[0].point.project(camera))
				var projected1 = new THREE.Vector3();
				var projected2 = new THREE.Vector3();
				console.log(captureRays)
				console.log(index_cam)
				projected1.copy(captureRays[index_cam])
				projected2.copy(intersectsCamera[0].point)
				projected1.project(camera)
				projected2.project(camera)
				console.log(projected1)
				console.log(projected2)
				var center = new THREE.Vector3(0,0,projected1.z);
				return projected1.distanceTo(center)
				//return intersectsPhoto[0].point.distanceTo(intersectsCamera[0].point);
				

			}
			function getScoreCam(index_cam, intersectsCamera)
			{
				var distanceScore = getScorePosition(index_cam);
				var orientationScore = getScoreRotation(index_cam);
				return distanceScore*0 + orientationScore*0 + getScoreRays(index_cam, intersectsCamera);
			}
			function compareCandidates( a, b ) {
			  if ( a.score < b.score ){
			    return -1;
			  }
			  if ( a.score > b.score ){
			    return 1;
			  }
			  return 0;
			}
			function updateCandidates()
			{
				console.log("START UPDATE")
				var directionCamera = new THREE.Vector3();
				camera.getWorldDirection( directionCamera );
				var raycasterCamera =  new THREE.Raycaster(camera.position, directionCamera);    
				var intersectsCamera = raycasterCamera.intersectObjects( scene_models );  
				console.log(intersectsCamera);

				var changed = false
				current_candidates = []
				var arrayLength = cameraList.length;
				for (var i = 0; i < arrayLength; i++) {
					
				    //cameraList[i].material.opacity = 0.1; 
				    var scoreCam = getScoreCam(i, intersectsCamera)
				    var elem = {
					    'index': i,
					    'score': scoreCam
					};
					console.log(captureNames[i]+" "+i + " score: "+ scoreCam)
					if(i >= current_candidates.length)
					{
						current_candidates.push(elem)
					}
				    else
				    {
				    	current_candidates[i] = elem
				    }
				}
				current_candidates.sort(compareCandidates)

				var directionCapture = new THREE.Vector3();
				var v1 = new THREE.Vector3();
				cameraList[current_candidates[0].index].getWorldDirection( directionCapture );
				var positionCapture = new THREE.Vector3();
				positionCapture.copy(cameraList[current_candidates[0].index].position);
				var cameraCapture = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 15 );
				//var cameraCapture = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0.1, 15 );

				//cameraCapture.matrixAutoUpdate  = true;
				
				cameraCapture.position.set( positionCapture.x,positionCapture.y,positionCapture.z );

				v1.copy( cameraList[current_candidates[0].index].up ).applyQuaternion( cameraList[current_candidates[0].index].quaternion );
				cameraCapture.quaternion.copy( cameraList[current_candidates[0].index].quaternion );
				cameraCapture.up.set(v1.x, v1.y, v1.z); 

				//var cameraCapture = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 15 );
				//cameraCapture.position.set( 11*0.03,-20*0.03,2*0.03 );
				//cameraCapture.up.set(0,0,1);

				cameraCapture.updateMatrixWorld();
				cameraCapture.updateProjectionMatrix();
				scene_models[0].material.uniforms.modelViewMatrixCapture.value = cameraCapture.matrixWorldInverse;
				scene_models[0].material.uniforms.projectionMatrixCapture.value = cameraCapture.projectionMatrix;
				showCaptures(true)
			}
			
			function changeMode()
			{
				if(camera_mode == "FLY")
					camera_mode = "ORBIT"
				else if(camera_mode == "ORBIT")
					camera_mode = "TRACK"
				else if(camera_mode == "TRACK")
					camera_mode = "FLY"
				else
					camera_mode = "FLY"
				initControls(camera_mode)
			}
			function initControls(mode)
			{
				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 15 );
				camera.position.set( 11*0.03,-20*0.03,2*0.03 );
				//camera.position.set( 3,0.15,3 );
				
				camera.up.set(0,0,1);


				if(mode == "FLY")
				{
					controls = new FlyControls( camera, renderer.domElement );
					controls.movementSpeed = 10;
					controls.domElement = renderer.domElement;
					controls.rollSpeed = Math.PI / 12;
					controls.autoForward = false;
					controls.dragToLook = false;
				}
				else if(mode == "ORBIT")
				{

					controls = new OrbitControls( camera, renderer.domElement );
					controls.minPolarAngle =  - Infinity; // radians
					controls.maxPolarAngle = Infinity; // radians
					controls.minDistance = 0;
					controls.maxDistance = 3;
					controls.minAzimuthAngle = - Infinity; // radians
					controls.maxAzimuthAngle = Infinity; // radians

					controls.target.set(-1*0.03,-20*0.03,2*0.03)

				}
				else if(mode == "TRACK")
				{
					controls = new TrackballControls( camera, renderer.domElement );
					controls.rotateSpeed = 1.0;
					controls.zoomSpeed = 0.6;
					controls.panSpeed = 0.2;

					controls.keys = [ 65, 83, 68 ];
					controls.target.set(-1*0.03,-20*0.03,2*0.03)
				}
				else
				{
					console.log("ERROR, mode not found");
				}
			}
			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );




				//camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
				//camera.position.set( 1000, 50, 1500 );

				//cameraTarget = new THREE.Vector3( 0, - 0.1, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x72645b );
				scene.fog = new THREE.Fog( 0x72645b, 2, 15 );



				loadModels();



				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;


				

				container.appendChild( renderer.domElement );

				// stats

				stats = new Stats();
				container.appendChild( stats.dom );

				initControls(camera_mode)
				




				window.addEventListener( 'resize', onWindowResize );

			}

			function addShadowedLight( x, y, z, color, intensity ) {

				const directionalLight = new THREE.DirectionalLight( color, intensity );
				directionalLight.position.set( x, y, z );
				scene.add( directionalLight );

				directionalLight.castShadow = true;

				const d = 1;
				directionalLight.shadow.camera.left = - d;
				directionalLight.shadow.camera.right = d;
				directionalLight.shadow.camera.top = d;
				directionalLight.shadow.camera.bottom = - d;

				directionalLight.shadow.camera.near = 1;
				directionalLight.shadow.camera.far = 4;

				directionalLight.shadow.mapSize.width = 1024;
				directionalLight.shadow.mapSize.height = 1024;

				directionalLight.shadow.bias = - 0.001;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				const timer = Date.now() * 0.0005;
				const delta = clock.getDelta();
				if(need_to_update)
					timer_update += delta

				if(old_pos_cam.distanceTo(camera.position) > 0.0001)
				{
					console.log("changed!! " + old_pos_cam.x + " " +camera.position.x)
					timer_update = 0;
					need_to_update = true;
				}
					
				requestAnimationFrame( animate );
				if(camera_mode != "FLY")
					controls.update();
				stats.update();
				if(timer_update > 1)
				{
					console.log("update")
					need_to_update = false
					timer_update = 0
					updateCandidates();
				}
				if(camera_mode == "FLY")
				{
					controls.movementSpeed = 0.33 * 1;
					controls.update( delta );
				}
				old_pos_cam.copy(camera.position);
				render();


			}

			function render() {
				renderer.clear();
				renderer.render( scene, camera );
			}



			var xmlhttp = new XMLHttpRequest();
			xmlhttp.onreadystatechange = function() {
			    if (this.readyState == 4 && this.status == 200) {
			        var myObj = JSON.parse(this.responseText);
			        var loader = new THREE.FileLoader();
			        loader.load('images/doma-interior.list.txt', function ( data ) {
					        // output the text to the console
					        captureNames = data.split('\n')
					        //console.log( data.split('\n') )
					        loadCameras(myObj)
			        		setDefaultColorsCameras();

						
					});
					
			    }
			};
			xmlhttp.open("GET", "cameras.json", true);
			xmlhttp.send();

		</script>
	</body>
</html>
