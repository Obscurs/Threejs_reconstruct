
<html lang="en">
	<head>
		<title>culture heritage viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

 <script src="modules/FileSaver.js"></script>
		<div id="info">
			3D view
		</div>
		<div id="info2">
			2D view
		</div>
		<div id="info3">	
		</div>
		<div class=container4 id="loadingTextContainer">
		  <p id="loadingText">Loading: 0% 
		</div>

		<script src="scripts/globals.js"></script>
		
<script type="module">
import * as THREE from '../build/three.module.js';
/*import Stats from './jsm/libs/stats.module.js';			
import { PLYLoader } from './jsm/loaders/PLYLoader.js';
import { OrbitControls } from './jsm/controls/CustomOrbitControls.js';
import { SelectionBox } from './jsm/interactive/SelectionBox.js';
import { SelectionHelper } from './jsm/interactive/SelectionHelper.js';
import { VRButton } from './jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from './jsm/webxr/XRControllerModelFactory.js';
import { DataLoader } from './scripts/DataLoader.js';
import {compareCandidates} from './scripts/compareFuncs.js';
import { getWorldIntersectFromNDCxy, getNDCposFromWorld, positionAtT, getWorldFromNDC} from './scripts/utils.js';
import { singleLinkageClustering, basicClustering} from './scripts/utils.js';
import { ModelInfo} from './scripts/ModelInfo.js';
import { CameraInfo} from './scripts/CameraInfo.js';

import { GUI } from './../jsm/libs/dat.gui.module.js';
import { Gui} from './scripts/Gui.js';
import { ThumbnailSprite } from './scripts/ThumbnailSprite.js';*/

import { Application } from './scripts/Application.js';

m_views[1].height = 0.3
m_views[1].width = (m_views[1].height*(window.innerWidth / window.innerHeight))*(1/(window.innerWidth / window.innerHeight))
m_views[1].left = 1.0-m_views[1].width
//init();
APPLICATION = new Application()


/*function moveToCapturePosition(index_capture)
{
	if(m_renderer.xr.isPresenting)
	{
		var newpos = new THREE.Vector3()
		var captureCam = m_camera_list[index_capture].camera
		newpos.copy(captureCam.position)
	    newpos.y = getFloorFromPos(newpos)
	    m_camera_group.position.copy(newpos)
	}
	else
	{
		var captureCam = m_camera_list[index_capture].camera
		var direction = new THREE.Vector3();
		captureCam.getWorldDirection( direction );
		m_camera.position.copy( captureCam.position )
		
		var v1 = new THREE.Vector3(); 
		
		m_controls.update()
		
		m_controls.target = new THREE.Vector3( captureCam.position.x+direction.x, captureCam.position.y+direction.y, captureCam.position.z+direction.z );

		m_controls.update()
	}

}


function changeCaptureInView(index_capture)
{
	m_has_any_secondary_capture = true
	var directionCapture = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	m_camera_list[index_capture].camera.getWorldDirection( directionCapture );
	var positionCapture = new THREE.Vector3();
	positionCapture.copy(m_camera_list[index_capture].camera.position);
	


	m_camera_capture.copy(m_camera_list[index_capture].camera,true)


	//TODO: GET THIS VALUE FROM FILE:
	m_camera_capture.aspect = m_camera_list[index_capture].width / m_camera_list[index_capture].height;
	m_camera_capture.updateMatrixWorld();
	m_camera_capture.updateProjectionMatrix();
	var viewMat = new THREE.Matrix4();
	var projMat = new THREE.Matrix4();

	var texture_low, material, plane, plane_rt;
	


	viewMat.copy(m_camera_capture.matrixWorldInverse);
	projMat.copy(m_camera_capture.projectionMatrix)
	m_scene_models[0].material.uniforms.viewMatrixCapture.value = viewMat;
	m_scene_models[0].material.uniforms.projectionMatrixCapture.value = projMat;
	m_camera_capture.fov = m_camera_list[index_capture].camera.fov+30

	const loaderLow = new THREE.TextureLoader();
	loaderLow.load(
		// resource URL
		"models/"+m_models_values[m_gui.gui_options.current_model].path+"/thumbnails/"+m_camera_list[index_capture].name,
		
		// onLoad callback
		function ( texture_low ) {
			// in this example we create the material when the texture is loaded
			if(m_camera_capture.name == tex_name)
			{
				//console.log(m_camera_capture.name + " "+tex_name)
				m_changed_image_in_view = 1
				console.log("INFO: Low tex loaded")
				if(m_scene_models.length >0)
					m_scene_models[0].material.uniforms.texture2.value = texture_low;
				if(m_plane_image_secondary != null)
					m_plane_image_secondary.material.uniforms.texture1.value = texture_low;
			}
			
		},
		// onError callback
		function ( err ) {
			console.error( 'Error trying to load texture (high res) for capture.' );
		}
	);

	const loader = new THREE.TextureLoader();
	var tex_name = m_camera_list[index_capture].name
	loader.load(
		// resource URL
		"models/"+m_models_values[m_gui.gui_options.current_model].path+"/captures/"+m_camera_list[index_capture].name,
		
		// onLoad callback
		function ( texture_high ) {
			// in this example we create the material when the texture is loaded
			if(m_camera_capture.name == tex_name)
			{
				//console.log(m_camera_capture.name + " "+tex_name)
				console.log("INFO: High tex loaded")
				m_changed_image_in_view = 1
				if(m_scene_models.length >0)
					m_scene_models[0].material.uniforms.texture2.value = texture_high;
				if(m_plane_image_secondary != null)
					m_plane_image_secondary.material.uniforms.texture1.value = texture_high;
			}
			
		},
		// onError callback
		function ( err ) {
			console.error( 'Error trying to load texture (high res) for capture.' );
		}
	);

	var frustumHeightWorld_photo = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_list[index_capture].camera.fov * 0.5 ));
	var frustumHeightWorld_view = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
	var scaleFact = frustumHeightWorld_view/frustumHeightWorld_photo;
	m_camera_capture.render_target_height = m_camera_list[index_capture].height*scaleFact
	m_camera_capture.render_target_width = m_camera_capture.render_target_height * m_camera_capture.aspect

	//m_render_target_secondary = new THREE.WebGLRenderTarget(m_camera_capture.render_target_width, m_camera_capture.render_target_height);
	m_render_target_secondary.setSize(m_camera_capture.render_target_width, m_camera_capture.render_target_height)

	//TODO: do this init once
	let uniforms = {
		  viewMatrixCapture: {type: 'mat4', value: viewMat},
		  projectionMatrixCapture: {type: 'mat4', value: projMat},
	        showTexture: {type: 'bool', value: true},
	        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
	        texture1: { type: "t", value: texture_low }
	    }
	const material_plane = new THREE.ShaderMaterial( { 
			uniforms: uniforms,
			fragmentShader: m_shaders.captureImageFrag,
			vertexShader: m_shaders.sceneVert,
		    blending: THREE.NormalBlending,
            depthTest: false,
            transparent: true
			//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
		} );

	
	plane = new THREE.Mesh(new THREE.PlaneGeometry(1.0001, 1.0001), material_plane);
	plane.name ="plane_photo"
	plane.translateZ( -(m_camera_capture.near+0.0001) );

	var existing = m_scene.getObjectByName("plane_photo");
	if(existing)
	{

		m_scene.remove( existing );
		existing.geometry.dispose();
		existing.material.dispose();
	}
		

	
	plane.applyMatrix(m_camera_capture.matrix)
	m_plane_image_secondary = plane;


	m_scene.add(m_plane_image_secondary)
	
	


	
	const material_plane_rt = new THREE.ShaderMaterial( { 
			uniforms: {tDiffuse: {value: m_render_target_secondary.texture}},
		    fragmentShader: m_shaders.screenFrag,
		    vertexShader: m_shaders.spriteVert,
		    depthTest: false,
		    depthWrite: false,
			//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
		} );

	plane_rt = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material_plane_rt);
	plane_rt.name ="plane_rt"
	plane_rt.position.z = -1

	m_plane_render_target = plane_rt
		
	if(m_renderer.xr.isPresenting)
	{
		if(m_plane_render_target != null)
			m_plane_render_target.renderOrder = 100
		plane_rt.position.x = + 0.75;
		plane_rt.rotation.y = -Math.PI / 3;
		//plane_rt.position.y = - 0.2;
		var existing = m_vr_panels_group.getObjectByName("plane_rt");
		if(existing){
			m_vr_panels_group.remove( existing );
			existing.geometry.dispose();
			existing.material.dispose();
		}
			
		
		if(m_plane_render_target != null && m_vr_move_utils.vrguiEnabled && m_gui.gui_options.show_view_enabled)
			m_vr_panels_group.add(m_plane_render_target);
	}
	else
	{
		if(m_plane_render_target != null)
		{
			m_plane_render_target.renderOrder = 0
			var existing = m_scene_capture.getObjectByName("plane_rt");
			if(existing){
				m_scene_capture.remove( existing );
				existing.geometry.dispose();
				existing.material.dispose();
			}
				
			//m_scene_capture.remove(m_plane_render_target)
		}
		m_scene_capture.add(m_plane_render_target)
	}
	

	m_controls_secondary.reset();

}
function selectCapture(index_capture, allow_jump = false)
{
	if(!m_gui.gui_options.show_photo_collection && !m_renderer.xr.isPresenting)
		return;
	if(m_application_state.need_to_update_auto_detect)
		return;

	if(m_current_capture_in_view_index == index_capture && allow_jump)
	{
		moveToCapturePosition(index_capture)
	}
	else
	{
		if(index_capture !=m_current_capture_in_view_index)
		changeCaptureInView(index_capture)
	}
	m_current_capture_in_view_index = index_capture;


	for(var i = 0; i < m_current_sprites_in_scene.children.length; ++i)
	{
		if(m_current_sprites_in_scene.children[i].getName() == m_current_capture_in_view_index && m_current_capture_in_view_index >=0)
			m_current_sprites_in_scene.children[i].setUniformSelected(true)
		else
			m_current_sprites_in_scene.children[i].setUniformSelected(false)
			
	}
	
}*/
/*
function setCollectionOpacity(opacity)
{
	var arrayLength = m_current_sprites_in_scene.children.length;
	for (var i = 0; i < arrayLength; i++) {
		m_current_sprites_in_scene.children[i].setUniformOpacity(opacity);
	}
	
}

function showCollectionSprite(_min_pos, _max_pos, index_capture, order, useNewSprites = false, isShifting = false, opacity = 1)
{
	var min_pos, max_pos, offset_x, offset_y;
	if(m_renderer.xr.isPresenting)
	{
		var hardcodedHeight = 2 * 4 * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
		var hardcodedWidth = hardcodedHeight * m_camera_capture.aspect;
		var scaleFx = hardcodedWidth/window.innerWidth
		var scaleFy = hardcodedHeight/window.innerHeight
		min_pos = new THREE.Vector3(_min_pos.x*scaleFx,_min_pos.y*scaleFy,0);
		max_pos = new THREE.Vector3(_max_pos.x*scaleFx,_max_pos.y*scaleFy,0);
		offset_x = -hardcodedWidth/2;
		offset_y = hardcodedHeight/2
	}
	else{
		min_pos = new THREE.Vector3(_min_pos.x,_min_pos.y,0);
		max_pos = new THREE.Vector3(_max_pos.x,_max_pos.y,0);
		offset_x = -window.innerWidth/2;
		offset_y = window.innerHeight/2
	}
	
	var scale = max_pos.x -min_pos.x



	if(useNewSprites)
	{
		var pathSprite = 'models/'+m_models_values[m_gui.gui_options.current_model].path+'/thumbnails/'+m_camera_list[index_capture].name
		var newsprite = new ThumbnailSprite(pathSprite, index_capture, m_camera_list[index_capture].width,m_camera_list[index_capture].height)
		m_current_sprites_in_scene.add(newsprite)
		m_camera_list[index_capture].spriteProperties.indexInGroup = m_current_sprites_in_scene.children.length -1
	}

	var sprite = m_current_sprites_in_scene.children[m_camera_list[index_capture].spriteProperties.indexInGroup]

	var existing = m_scene_collections.getObjectByName(sprite.name);
	var _x = min_pos.x+offset_x
	var _y = min_pos.y+offset_y
	var spritepos = new THREE.Vector3(_x,_y,0);
	if(m_renderer.xr.isPresenting)
	{
		spritepos.z = -order*0.25
	}
	sprite.scale.set(scale, scale, 1);
	sprite.position.set(spritepos.x+scale/2,spritepos.y-scale/2, spritepos.z);
	if(m_renderer.xr.isPresenting)
	{
		sprite.renderOrder = -order;
	}
	else
	{
		sprite.renderOrder = order;
	}
	
	
	sprite.setUniformMinSel(m_camera_list[index_capture].spriteProperties.minSel)
	sprite.setUniformMaxSel(m_camera_list[index_capture].spriteProperties.maxSel)
	sprite.setUniformSelected(m_current_capture_in_view_index == sprite.name)
	sprite.setUniformOpacity(opacity);
	


}

function showCollection(min_pos, max_pos, index_collection, useNewSprites = false, isShifting = false, offsetAnim = 0)
{
	var animOffset = 0;
	if(offsetAnim > 0)
	{
		animOffset = 1-offsetAnim;
	} else if(offsetAnim < 0)
	{
		animOffset = -(offsetAnim+1);
	}
	var offset_per_image = 10-2*i;
	if(offset_per_image < 2)
		offset_per_image = 2
	
	offset_per_image = 2
	var half_offset_per_image = offset_per_image/2
	var currentOffset = new THREE.Vector2(half_offset_per_image+animOffset*half_offset_per_image,half_offset_per_image+animOffset*half_offset_per_image)
	var remaining_width = max_pos.x-min_pos.x-currentOffset.x;
	var remaining_height = max_pos.y-min_pos.y-currentOffset.y;

	var num_elems = m_current_candidates_collections[index_collection].elems.length
	var width_image = remaining_width-num_elems*offset_per_image
	var height_image = remaining_height-num_elems*offset_per_image
	for(var i = num_elems-1; i >= 0; i--)
	{
		var min = new THREE.Vector3( min_pos.x+currentOffset.x, min_pos.y-currentOffset.y,-1 );
		var max = new THREE.Vector3( min_pos.x+currentOffset.x+width_image+animOffset*half_offset_per_image ,min_pos.y+currentOffset.y+height_image+animOffset*half_offset_per_image,-1);
		currentOffset.x = currentOffset.x + offset_per_image;
		currentOffset.y = currentOffset.y + offset_per_image;
		var opacity = 1
		if(animOffset > 0 && i == 0)
		{
			opacity = 1 - animOffset
		} else if(animOffset < 0 && i == num_elems-1)
		{
			opacity = 1 - animOffset*(-1)
		}
			
		showCollectionSprite(min, max, m_current_candidates_collections[index_collection].elems[i],num_elems-i,useNewSprites, isShifting, opacity)
	}
	
}
function clearCollectionSprites()
{
	while(m_current_sprites_in_scene.children.length > 0){ 
		m_current_sprites_in_scene.children[0].dispose();
	    m_current_sprites_in_scene.remove(m_current_sprites_in_scene.children[0]); 
	}
}
function showCollections(useNewSprites)
{
	var remaining_width = window.innerWidth-200;
	var current_min_x = 0;
	var collection_height = 500
	var sprites_to_remove = []
	
	if(useNewSprites)
		clearCollectionSprites()


	for(var i = 0; i < m_current_candidates_collections.length; i++)
	{
		var collection_width = remaining_width/4
		var min = new THREE.Vector2( current_min_x, 0 );
		var max = new THREE.Vector2(current_min_x+ collection_width,collection_height);
		m_current_candidates_collections[i].min = min;
		m_current_candidates_collections[i].max = max;
		showCollection(min,max,i, useNewSprites);
		remaining_width = remaining_width - collection_width;
		current_min_x = current_min_x + collection_width;
	}


}*/


/*
function getCaptureUnderMouse(event)
{
	if(!m_gui.gui_options.show_photo_collection && !m_renderer.xr.isPresenting)
		return -1;
	if(m_application_state.need_to_update_auto_detect)
		return -1;
    var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
                            -( event.clientY / window.innerHeight ) * 2 + 1,  
                            0.5 );     
    var raycaster =  new THREE.Raycaster();                                        
   raycaster.setFromCamera( mouse3D, m_camera_collections );
    var intersects = raycaster.intersectObjects( m_current_sprites_in_scene.children );


    if ( intersects.length > 0 ) 
    {
    	var curr_index = intersects[ 0 ].object.name
    	var curr_depth = intersects[ 0 ].object.renderOrder
    	for(var i=0; i <intersects.length; i++)
    	{
    		if(intersects[ i ].object.renderOrder > curr_depth)
    		{
    			curr_depth = intersects[ i ].object.renderOrder;
    			curr_index = intersects[ i ].object.name;
    		}
    	}
    	return curr_index
    }
    else
    	return -1
}

function getCollectionIndexUnderMouse()
{
	if(!m_gui.gui_options.show_photo_collection && !m_renderer.xr.isPresenting)
		return -1;
	if(m_application_state.need_to_update_auto_detect)
		return -1;
	if(m_application_state.capture_index_over_mouse != -1)
	{
		var index_collection = -1
		for(var i=0; i<m_current_candidates_collections.length; i++)
		{
			for(var j=0; j < m_current_candidates_collections[i].elems.length; j++)
			{
				if(m_current_candidates_collections[i].elems[j] == m_application_state.capture_index_over_mouse)
				{
					index_collection = i;
					break;
				}
			}
			
		}
		return index_collection;
	}
	return -1;
}*/
/*function onDocumentKeyDown(event) {
	if(m_application_state.state == AppStates.READY_TO_GO)
	{
		var keyCode = event.which;
	    if (keyCode == 82) { //R
	        resetCamera("ORBIT");

	    }else if(keyCode == 87) { //W
	    	var collection = getCollectionIndexUnderMouse()
			if(collection >=0 && m_current_candidates_collections[collection].elems.length > 1)
			{
				m_current_candidates_collections[collection].animating = -1			
			}

	    }else if(keyCode == 83) { //S
	    	var collection = getCollectionIndexUnderMouse()
			if(collection >=0 && m_current_candidates_collections[collection].elems.length > 1)
			{
				m_current_candidates_collections[collection].animating = +1			
			}

	    }  else if (keyCode == 17) { //Control
	    	m_gui.disableGui()
	    	m_application_state.select_controls_enabled = true;
	    	m_controls.enabled = false;
	    	m_controls_secondary.enabled = false;
	    	m_selection_rectangle.helper.element.hidden = false;
	    	
	    }
	     else if (keyCode == 32) { //Space
	    	if(m_recording_state == 0)
	    	{
	    		m_recording_distance = 0;
	    		m_recording_timer = 0;
	    		m_recording_state = 1;
	    		document.getElementById("info3").innerHTML  = "Recording...";
	    	}
	    	else if(m_recording_state == 1)
	    	{
	    		document.getElementById("info3").innerHTML  = "";
	    		m_recording_state = 0;
	    		Math.round(m_recording_distance * 100) / 100

	    		alert("Time elapsed: "+(Math.round(m_recording_timer * 100) / 100)+" seconds\nDistance traveled: "+(Math.round(m_recording_distance * 100) / 100)+" meters");
	    		//console.log(m_recording_timer)
	    		//console.log(m_recording_distance)
	    	}

	    		

	    }
	}
};*/






/*function onDocumentPointerMove(event)
{
	if(!m_application_state.state == AppStates.READY_TO_GO)
		return;
	var captureIndex = getCaptureUnderMouse(event);
	if(captureIndex >= 0)
	{
		//document.getElementById("info").focus();
		if(m_gui && m_gui.enabled)
		{

			m_gui.removeFocus()
		}
		//console.log("mouse move, capture: "+ captureIndex)

		m_application_state.capture_index_over_mouse = captureIndex;
		if(m_controls)
			m_controls.enabled = false;
		if(m_controls_secondary)
			m_controls_secondary.enabled = false;
	}
	else
	{
		if(!m_application_state.select_controls_enabled && !m_application_state.views_swaped)
		{
			if(m_controls)
				m_controls.enabled = true;
		}
			
		if(m_controls_secondary && m_application_state.views_swaped)
			m_controls_secondary.enabled = true;
		m_application_state.capture_index_over_mouse = -1;
	}
		
	if(m_application_state.select_controls_enabled && m_dragging)
	{
		var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );   
		m_selection_rectangle.endNDC = mouseNDC

		m_selection_rectangle.selectionBox.endPoint.set(
						( event.clientX / window.innerWidth ) * 2 - 1,
						- ( event.clientY / window.innerHeight ) * 2 + 1,
						0.5 );
	}
	else
	{

	}
}
function onDocumentPointerDown(event)
{
	if(!m_application_state.state == AppStates.READY_TO_GO)
	return;
	if(m_application_state.select_controls_enabled)
	{
		//document.getElementById("selection_menu").style.display = "none";
		

		
		var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );   
		
		m_selection_rectangle.startNDC = mouseNDC
		m_selection_rectangle.endNDC = mouseNDC
		var auxNDC = new THREE.Vector2(mouseNDC.x, mouseNDC.y);

		
		//console.log("NDC down" + mouseNDC);
		m_dragging = true;

		m_selection_rectangle.selectionBox.startPoint.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1,
					0.5 );
	}
	else
	{
		if(m_gui.gui_options.show_view_enabled)
		{
			var mouseWindwNorm = new THREE.Vector3( ( event.clientX / window.innerWidth ),   
	                                    1-( event.clientY / window.innerHeight ),  
	                                    0.5 );   
			

			console.log(mouseWindwNorm)
			if(mouseWindwNorm.x >m_views[1].left && mouseWindwNorm.x < m_views[1].left +m_views[1].width && mouseWindwNorm.y >m_views[1].bottom && mouseWindwNorm.y <m_views[1].bottom+m_views[1].height)
			{
				m_application_state.views_swaped = !m_application_state.views_swaped;
				if(m_application_state.views_swaped)
				{
					document.getElementById("info").innerHTML  = "2D view";
					document.getElementById("info2").innerHTML  = "3D view";
					m_controls_secondary.enabled = true;
					m_controls_secondary.update()
					m_controls.enabled = false;
				}
				else
				{
					document.getElementById("info").innerHTML  = "3D view";
					document.getElementById("info2").innerHTML  = "2D view";
					m_controls_secondary.enabled = false;
					m_controls.enabled = true;
				}
			}
		}
		

	}
}

function onDocumentMouseWheel(event)
{
	var collection = getCollectionIndexUnderMouse()
	if(collection >=0 && m_current_candidates_collections[collection].elems.length > 1)
	{
		if(event.wheelDelta > 0)
		{
			m_current_candidates_collections[collection].animating = 1
		}
		else
		{
			m_current_candidates_collections[collection].animating = -1
		}
	}

}
function onDocumentPointerUp( event ) {   
	if(!m_application_state.state == AppStates.READY_TO_GO)
		return;
	if(m_application_state.select_controls_enabled)
	{
		
		m_dragging = false;
		var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
                            -( event.clientY / window.innerHeight ) * 2 + 1,  
                            0.5 );   
		m_selection_rectangle.endNDC = mouseNDC

		m_selection_rectangle.selectionBox.endPoint.set(
		( event.clientX / window.innerWidth ) * 2 - 1,
		- ( event.clientY / window.innerHeight ) * 2 + 1,
		0.5 );

		updateCandidates(true);
	}
	else
	{
		var captureIndex = getCaptureUnderMouse(event);
		if(captureIndex >= 0)
			selectCapture(captureIndex, true)
	}
}*/

/*
function loadCamera(element, index, array)
{
	console.log("      Loading Camera "+element.name+" ...")

 	var m = new THREE.Matrix4();
	m.set( element.m1, element.m2, element.m3, element.tx,
       element.m4, element.m5, element.m6, element.ty,
       element.m7, element.m8, element.m9, element.tz,
       0, 0, 0, 1 );
	m.invert();


	var m2 = new THREE.Matrix4();

	m2.makeRotationX(THREE.Math.degToRad(-90))
	m2.multiply(m)




	var fov_y = 2*Math.atan(element.height/(2*element.f))
	var fov_x = 2*Math.atan(element.width/(2*element.f))

	var capture_camera = new THREE.PerspectiveCamera( fov_y*(180/Math.PI), element.width / element.height, 0.1, 100 );

	capture_camera.applyMatrix4(m2);
	capture_camera.name = element.name


	capture_camera.updateMatrixWorld();
	capture_camera.updateProjectionMatrix();
	
	var new_camera = new CameraInfo(
		element.name,
		element.width,
		element.height,
		m,
		element.f,
		null,//mesh for debug
		capture_camera
	);
	
	m_camera_list.push(new_camera);
	
	m_application_state.num_cameras_loaded +=1

	var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
	document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";
	if(m_min_pos == null)
	{
		m_min_pos = new THREE.Vector3(capture_camera.position.x,capture_camera.position.y,capture_camera.position.z)
	}
	if(m_max_pos == null)
	{
		m_max_pos = new THREE.Vector3(capture_camera.position.x,capture_camera.position.y,capture_camera.position.z)
	}
	if(m_min_pos.x > capture_camera.position.x)
		m_min_pos.x = capture_camera.position.x
	if(m_min_pos.y > capture_camera.position.z)
		m_min_pos.y = capture_camera.position.z
	if(m_min_pos.z > capture_camera.position.z)
		m_min_pos.z = capture_camera.position.z

	if(m_max_pos.x < capture_camera.position.x)
		m_max_pos.x = capture_camera.position.x
	if(m_max_pos.y < capture_camera.position.z)
		m_max_pos.y = capture_camera.position.z
	if(m_max_pos.z < capture_camera.position.z)
		m_max_pos.z = capture_camera.position.z
	console.log("      Loading Camera "+element.name+" : DONE")

}

function loadCameras(cameras) {
	m_application_state.num_cameras_to_load = cameras.cameras.length
	console.log("INFO: Loading cameras...")
	cameras.cameras.forEach((loadCamera));
}
function loadModel(model)
{
	console.log("INFO: Loading "+model.path+"...")
	const loader = new PLYLoader();
	const loaderTex = new THREE.TextureLoader(m_manager);


	loader.load( './models/'+model.path+'/meshes/'+model.mesh_name+"_colision_ground.ply", function ( geometry ) {
		geometry.computeVertexNormals();
		
	    const material = new THREE.MeshBasicMaterial( {
			opacity: 0.0,
			transparent: true,
		} );

		const mesh = new THREE.Mesh( geometry, material );

		var m2 = new THREE.Matrix4();
		m2.makeRotationX(THREE.Math.degToRad(-90))

		mesh.applyMatrix4(m2);

		mesh.isGUI = false
		mesh.name = PointedObjectNames.GROUND
		m_scene.add( mesh );
		m_scene_models_col.push(mesh);

		m_application_state.num_models_loaded +=1
		console.log("INFO: Loading Model Col ground: DONE")
		var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
		document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";


	} );
	loader.load( './models/'+model.path+'/meshes/'+model.mesh_name+"_colision_select.ply", function ( geometry ) {
		geometry.computeVertexNormals();
		
	    const material = new THREE.MeshBasicMaterial( {
			opacity: 0.0,
			transparent: true,
		} );

		const mesh = new THREE.Mesh( geometry, material );

		var m2 = new THREE.Matrix4();
		m2.makeRotationX(THREE.Math.degToRad(-90))

		mesh.applyMatrix4(m2);

		mesh.isGUI = false
		mesh.name = PointedObjectNames.WALL
		m_scene.add( mesh );
		m_scene_models_col.push(mesh);

		m_application_state.num_models_loaded +=1
		console.log("INFO: Loading Model Col select: DONE")
		var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
		document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";


	} );

	loader.load( './models/'+model.path+'/meshes/'+model.mesh_name+".ply", function ( geometry ) {
		geometry.computeVertexNormals();
		let uniforms = {
	        viewMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
	        projectionMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
	        showRedArea: {type: 'bool', value: false},
	        projectCapture: {type: 'bool', value: false},
	        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
	        texture1: { type: "t", value: loaderTex.load('./models/'+model.path+'/textures/'+m_models_values[m_gui.gui_options.current_model].texture_name) },
	        texture2: { type: "t", value: null },
	        squareVR: {type: 'bool', value: false},
	        vUv_VR_square_min: {type: 'vec2', value: new THREE.Vector2()},
	        vUv_VR_square_max: {type: 'vec2', value: new THREE.Vector2()},

	    }
		const material = new THREE.ShaderMaterial( { 
			uniforms: uniforms,
		    fragmentShader: m_shaders.sceneFrag,
			vertexShader: m_shaders.sceneVert,
			//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
		} );
		const mesh = new THREE.Mesh( geometry, material );

		var m2 = new THREE.Matrix4();
		m2.makeRotationX(THREE.Math.degToRad(-90))

		mesh.applyMatrix4(m2);
		//mesh.scale.multiplyScalar( 0.03 );
		//mesh.rotation.x = - Math.PI / 2;


		
		 

		mesh.castShadow = true;
		mesh.receiveShadow = true;
		mesh.name = "THEMODEL"
		m_scene.add( mesh );
		m_scene_models.push(mesh);

		//TODO Check cams loaded
		m_application_state.num_models_loaded +=1
		console.log("INFO: Loading Model: DONE")
		var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
		document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";

		//precomputeRays()

	} );
} 

function loadModels()
{
	m_application_state.num_models_to_load = 3
	loadModel(m_models_values[m_gui.gui_options.current_model]);

}

function toggleEnableCams()
{
	m_cams_enabled = !m_cams_enabled;
	var arrayLength = m_camera_list.length;
	if(m_cams_enabled)
	{
		for (var i = 0; i < arrayLength; i++) {
		    m_camera_list[i].mesh.material.opacity = 0.1; 
		}
	}
	else
	{
		for (var i = 0; i < arrayLength; i++) {
		    m_camera_list[i].mesh.material.opacity = 0.0; 
		}
	}
}
function getScorePosition(index_cam)
{
	var dist_max_aprox = (m_min_pos.distanceTo(m_max_pos))*2
	var dist = m_camera_list[index_cam].camera.position.distanceTo(m_camera.position)
	if(dist > dist_max_aprox)
		dist = dist_max_aprox;
	return (dist_max_aprox-dist)/dist_max_aprox;
	
}
function getScoreRotation(index_cam)
{
	var direction1 = new THREE.Vector3();
	var direction2 = new THREE.Vector3();
	m_camera_list[index_cam].camera.getWorldDirection( direction1 );
	m_camera.getWorldDirection( direction2 );
	var dist = direction1.distanceTo(direction2);
	return dist/2;
	
}
function getScoreRays(index_cam, intersectsCamera, min_x, max_x, min_y, max_y)
{

	m_camera.updateProjectionMatrix();
	m_camera.updateMatrixWorld();
	var count_inside_rays = 0
	var camera;
	if(m_renderer.xr.isPresenting)
	{
		//m_renderer.xr.getCamera(m_camera).getWorldPosition(m_vr_move_utils.tempVec);
		camera = m_renderer.xr.getCamera(m_camera);
	}
	else
	{
		camera = m_camera;
		
	}
	for(var index_ray = 0; index_ray <m_camera_list[index_cam].rays.length; ++index_ray)
	{
		var projected = new THREE.Vector3();
		projected.copy(m_camera_list[index_cam].rays[index_ray])
		projected.project(camera)
			
		var aux_x_min = min_x
		var aux_y_min = min_y
		var aux_x_max = max_x
		var aux_y_max = max_y

		if(max_y < min_y)
		{
			aux_y_min = max_y
			aux_y_max = min_y
		}
		if(max_x < min_x)
		{
			aux_x_min = max_x
			aux_x_max = min_x
		}
		if(projected.x > aux_x_min && projected.x < aux_x_max && projected.y > aux_y_min && projected.y < aux_y_max)
		{
			//console.log("added " + index_cam)
			//console.log(projected.z)
			var projected2 = new THREE.Vector3();
			projected2.copy(m_camera_list[index_cam].rays[index_ray])
			projected2.applyMatrix4( camera.matrixWorldInverse );
			if(projected2.z < 0)
				count_inside_rays = count_inside_rays +1
		}
			
	}
	//console.log(m_camera_list[index_cam].name +" "+count_inside_rays)
	if(m_camera_list[index_cam].rays.length > 0)
		return count_inside_rays/m_camera_list[index_cam].rays.length
	else
		return 0
	//return intersectsPhoto[0].point.distanceTo(intersectsCamera[0].point);
	

}


function getScoreCam(index_cam, intersectsCamera, usingSelectionRectangle)
{
	var distanceScore, orientationScore, raysScore;
	distanceScore = orientationScore = raysScore = 0;
	if(usingSelectionRectangle)
	{
		raysScore = getScoreRays(index_cam, intersectsCamera,m_selection_rectangle.startNDC.x,m_selection_rectangle.endNDC.x,m_selection_rectangle.startNDC.y,m_selection_rectangle.endNDC.y);

		var minNDCpoint = getNDCposFromWorld(m_camera_list[index_cam].camera, m_selection_rectangle.startWorld)
		var maxNDCpoint = getNDCposFromWorld(m_camera_list[index_cam].camera, m_selection_rectangle.endWorld)
		//console.log("minmax")
		//console.log(minNDCpoint)
		//console.log(maxNDCpoint)
		if(minNDCpoint != null && maxNDCpoint !=null)
		{
			if(minNDCpoint.x >maxNDCpoint.x)
			{
				var aux = minNDCpoint.x;
				minNDCpoint.x = maxNDCpoint.x;
				maxNDCpoint.x = aux;
			}
			if(minNDCpoint.y >maxNDCpoint.y)
			{
				var aux = minNDCpoint.y;
				minNDCpoint.y = maxNDCpoint.y;
				maxNDCpoint.y = aux;
			}
			m_camera_list[index_cam].spriteProperties.minSel = new THREE.Vector2((minNDCpoint.x+1)/2,(minNDCpoint.y+1)/2);
			m_camera_list[index_cam].spriteProperties.maxSel = new THREE.Vector2((maxNDCpoint.x+1)/2,(maxNDCpoint.y+1)/2);
		}
		else
		{
			m_camera_list[index_cam].spriteProperties.minSel = new THREE.Vector2(0.0,0.0);
			m_camera_list[index_cam].spriteProperties.maxSel = new THREE.Vector2(0.0,0.0);
		}
		
		return raysScore;
	}
	else
	{
		if(m_gui.gui_options.position)
			distanceScore = getScorePosition(index_cam);
		if(m_gui.gui_options.orientation)
			orientationScore = getScoreRotation(index_cam);
		if(m_gui.gui_options.projection)
			raysScore = getScoreRays(index_cam, intersectsCamera,-1,1,-1,1);

		m_camera_list[index_cam].spriteProperties.minSel = new THREE.Vector2(0.0,0.0);
		m_camera_list[index_cam].spriteProperties.maxSel = new THREE.Vector2(0.0,0.0);
		return distanceScore*m_gui.gui_options.position + orientationScore*m_gui.gui_options.orientation + raysScore*m_gui.gui_options.projection;
	}

	
}*/


/*function shiftCollectionSprites(collection,index, direction)
{
	if(direction > 0)
	{
		var elem = collection.elems.shift()
		collection.elems.push(elem)
		//console.log("shifted1")
	} else
	{
		var elem = collection.elems.pop();
		collection.elems.unshift(elem);
		//console.log("shifted2")
	}
	
}
function updateCollectionsAnims(delta)
{
	for(var i=0; i < m_current_candidates_collections.length; i++)
	{
		if(m_current_candidates_collections[i].animating !=0)
		{
			var value_shift = m_current_candidates_collections[i].animating
			if(m_current_candidates_collections[i].animating >0)
			{
				m_current_candidates_collections[i].animating = m_current_candidates_collections[i].animating - delta*2;
				if(m_current_candidates_collections[i].animating < 0)
					m_current_candidates_collections[i].animating = 0
			}
			else 
			{
				m_current_candidates_collections[i].animating = m_current_candidates_collections[i].animating + delta*2;
				if(m_current_candidates_collections[i].animating > 0)
					m_current_candidates_collections[i].animating = 0
			}
			if(m_current_candidates_collections[i].animating == 0)
				shiftCollectionSprites(m_current_candidates_collections[i],i, value_shift)
			var offset = m_current_candidates_collections[i].animating
			showCollection(m_current_candidates_collections[i].min, m_current_candidates_collections[i].max,i, false, true, offset)
		}
	}
	//m_application_state.
}
*/
/*function updateCandidateCollections()
{
	//TODO clear m_current_candidates_collections???
	//TODO use structure for m_current_candidates
	if(m_gui.gui_options.clustering_method == 'single_linkage')
		m_current_candidates_collections = singleLinkageClustering(m_gui.gui_options.max_num_collections, m_gui.gui_options.max_collection_size, m_camera_list, m_current_candidates);
	else
		m_current_candidates_collections = basicClustering(m_gui.gui_options.max_num_collections, m_gui.gui_options.max_collection_size, m_gui.gui_options.similitude_treshold, m_gui.gui_options.max_num_collections, m_camera_list, m_current_candidates);

	if(m_renderer.xr.isPresenting)
	{
		var vrCollections = []
		
		for(var i=0; i <m_current_candidates_collections.length; ++i)
		{
			var elems = []
			for(var j=0; j <m_current_candidates_collections[i].elems.length; ++j)
			{
				var cameraInfo = m_camera_list[m_current_candidates_collections[i].elems[j]]
				var vrColElem = {
					imagePath: 'models/'+m_models_values[m_gui.gui_options.current_model].path+'/thumbnails/'+cameraInfo.name,
					index: m_current_candidates_collections[i].elems[j],
					camInfo: cameraInfo,
				}
				elems.push(vrColElem)
			}	
			vrCollections.push(elems)
		}
		m_VRControls.updateVRCollections(vrCollections);
	}
}*/
/*function normalizeScores()
{
	var biggest_score = m_current_candidates[0].score;
	for (var i = 0; i < m_current_candidates.length; i++) {
		m_current_candidates[i].score = m_current_candidates[i].score/biggest_score;
	}
}
function updateCandidates(usingSelectionRectangle)
{
	console.log("INFO: Updating candidates...")

	var changed = false
	m_current_candidates = []
	var arrayLength = m_camera_list.length;

	if(usingSelectionRectangle)
	{
		if(m_renderer.xr.isPresenting)
		{	
			var vec1aux = new THREE.Vector3()
			var vec2aux = new THREE.Vector3()
			var camera = m_renderer.xr.getCamera(m_camera)
			m_selection_rectangle.startWorld = m_vr_move_utils.drawBoxStartPoint.ray;
			m_selection_rectangle.endWorld = m_vr_move_utils.drawBoxEndPoint.ray;
			m_selection_rectangle.startNDC = getNDCposFromWorld(camera,m_selection_rectangle.startWorld)
			m_selection_rectangle.endNDC = getNDCposFromWorld(camera,m_selection_rectangle.endWorld)

			console.log(m_selection_rectangle.startNDC)
			console.log(m_selection_rectangle.endNDC)
			console.log(camera.getWorldPosition(vec1aux))
			console.log(camera.getWorldDirection(vec2aux))
		}
		else
		{
			var minWorldPoint = getWorldIntersectFromNDCxy(m_camera,m_selection_rectangle.startNDC,m_scene_models);
			var maxWorldPoint = getWorldIntersectFromNDCxy(m_camera,m_selection_rectangle.endNDC,m_scene_models);
			console.log(m_selection_rectangle.startNDC)
			console.log(m_selection_rectangle.endNDC)
			m_selection_rectangle.startWorld = minWorldPoint;
			m_selection_rectangle.endWorld = maxWorldPoint;
		}
		
	}
	for (var i = 0; i < arrayLength; i++) {
	    var scoreCam = getScoreCam(i, null, usingSelectionRectangle)
	    var elem = {
		    'index': i,
		    'score': scoreCam,
		    'collection_index': -1,
		};
		//console.log(m_camera_list[i].name+" "+i + " score: "+ scoreCam)
		if(isNaN(elem.score) )
			elem.score = 0;
		
		if(i >= m_current_candidates.length)
		{
			m_current_candidates.push(elem)
		}

	}
	m_current_candidates.sort(compareCandidates)
	normalizeScores()
	updateCandidateCollections()

	showCollections(true)
	console.log("INFO: Updating candidates: DONE")
}*/



/*function resetCamera(mode)
{

	if(m_cameraHelper)
	{
		m_scene.remove(m_cameraHelper)
	}

	console.log("RESET CAMERA")
	m_camera_capture_orto = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0, 10);


	m_camera_collections = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0, 10);

	var start_x = m_models_values[m_gui.gui_options.current_model].pos_x_cam_start
	var start_y = m_models_values[m_gui.gui_options.current_model].pos_y_cam_start
	var start_z = m_models_values[m_gui.gui_options.current_model].pos_z_cam_start

	var target_x = m_models_values[m_gui.gui_options.current_model].target_x_cam_start
	var target_y = m_models_values[m_gui.gui_options.current_model].target_y_cam_start
	var target_z = m_models_values[m_gui.gui_options.current_model].target_z_cam_start
	if(!m_camera)
		m_camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );
	if(!m_renderer.xr.isPresenting)
		m_camera.position.set( start_x,start_y,start_z );
	else
	{
		m_camera.position.set( 0,0,0 );
	}
	m_camera.name = "main_camera"

	m_camera_capture = new THREE.PerspectiveCamera( 50.5, 4000 / 2950, 0.1, 100 );
	m_camera_capture.position.set( start_x,start_y,start_z );
	m_cameraHelper = new THREE.CameraHelper(m_camera_capture);

	if(mode == "ORBIT")
	{

		m_controls = new OrbitControls( m_camera, m_renderer.domElement );
		m_controls.minPolarAngle =  - Infinity; // radians
		m_controls.maxPolarAngle = Infinity; // radians
		m_controls.minDistance = 1;
		m_controls.maxDistance = 30;
		m_controls.minAzimuthAngle = - Infinity; // radians
		m_controls.maxAzimuthAngle = Infinity; // radians

		m_controls.target.set(target_x,target_y,target_z)

		
		m_controls_secondary = new OrbitControls( m_camera_capture_orto, m_renderer.domElement );
		m_controls_secondary.minPolarAngle =  - Infinity; // radians
		m_controls_secondary.maxPolarAngle = Infinity; // radians
		m_controls_secondary.minDistance = 0;
		m_controls_secondary.maxDistance = 3;
		m_controls_secondary.minAzimuthAngle = - Infinity; // radians
		m_controls_secondary.maxAzimuthAngle = Infinity; // radians
		m_controls_secondary.enabled = false;
	}
	else
	{
		if(m_controls)
			m_controls.enabled = false
	}
	m_camera_group.position.set(0,0,0)

	m_camera_group.add(m_camera)
	m_scene.add(m_cameraHelper);
}
function initControls(mode)
{
	resetCamera(mode)
	m_scene.add(m_camera_group);
}*/

/*function clearSceneData()
{
	m_gui.disableGui()
	//APL STATE
	m_application_state.state = AppStates.THREE_JS_INIT_SHADERS;
	m_application_state.num_cameras_loaded = 0;
	m_application_state.num_models_loaded = 0;
	m_application_state.three_js_inited = false;
	m_application_state.num_cameras_to_load = 0;
	m_application_state.num_models_to_load = 0;
	m_application_state.precomputed_file_loaded = false;
	m_application_state.precomputation_done = false;
	m_application_state.textures_loaded = false;
	m_application_state.count_precomputation_iterations = 0;
	m_application_state.capture_index_over_mouse = -1;
	m_application_state.transition_animation_step = 1.0;
	m_application_state.views_swaped = false;
	m_application_state.select_controls_enabled = false;
	m_application_state.need_to_update_auto_detect = false;
	m_application_state.inVR = false;
	m_recording_distance = 0;
	m_recording_timer = 0;
	m_recording_state = 0;
	document.getElementById("info3").innerHTML  = "";
	m_rectangle_select_vr = null;
	m_old_vr_input_data = null;

	m_min_pos = null;
	m_max_pos = null;

	m_has_any_secondary_capture = false;
	m_plane_image_secondary = null;
	if(m_gui)
		m_gui.clearInteractiveGroup(m_vr_panels_group)
	m_camera_list = [];
	m_scene_models = [];
	m_scene_models_col = [];
	m_current_candidates = [];
	m_current_candidates_collections = [];

	m_timer_update = 0;
	m_cams_enabled = false;
	m_current_capture_in_view_index = -1;
	m_capture_rays_need_recomputation = true;

	m_dragging = false;
	while(m_current_sprites_in_scene.children.length > 0){ 
		m_current_sprites_in_scene.children[0].dispose();
	    m_current_sprites_in_scene.remove(m_current_sprites_in_scene.children[0]); 
	}
	

	while(m_scene.children.length > 0){ 
		if(m_scene.children[0].geometry)
			m_scene.children[0].geometry.dispose();
		if(m_scene.children[0].material)
			m_scene.children[0].material.dispose();
	    m_scene.remove(m_scene.children[0]); 
	}

	while(m_scene_capture.children.length > 0){
		if(m_scene_capture.children[0].geometry) 
			m_scene_capture.children[0].geometry.dispose();
		if(m_scene_capture.children[0].material) 
			m_scene_capture.children[0].material.dispose();
	    m_scene_capture.remove(m_scene_capture.children[0]); 
	}
	if(m_vr_panels_group)
	{
		while(m_vr_panels_group.children.length > 0){ 
		    m_vr_panels_group.remove(m_vr_panels_group.children[0]); 
		}
	}
	
	
}*/
/*function startSceneForModel()
{

	clearSceneData()
	m_vr_panels_group = new THREE.Group();
	m_vr_panels_group.name = "vr_panels_group"
	m_camera_group = new THREE.Group()
	m_camera_group.name = "cameraGroup"
	m_camera_group.add(m_vr_panels_group)

	
	document.getElementById("loadingTextContainer").style.visibility = "visible";
	var xmlhttp = new XMLHttpRequest();
	xmlhttp.onreadystatechange = function() {
	    if (this.readyState == 4 && this.status == 200) {
	        var myObj = JSON.parse(this.responseText);
	        console.log("INFO: Capture info json loading... DONE")
	        loadCameras(myObj)
	    }
	};
	xmlhttp.open("GET", 'models/'+m_models_values[m_gui.gui_options.current_model].path+"/capture_info/cameraInfo.json", true);
	console.log("INFO: Capture info json loading...")
	xmlhttp.send();

	loadModels();
	initControls(m_camera_mode)
	m_VRControls = new VRControls(m_scene,m_renderer, m_camera, m_camera_group, null)
	m_gui.initInteractiveGroup(m_renderer, m_camera, m_scene, m_vr_panels_group, m_vr_move_utils)
	

	m_application_state.three_js_inited = true
	animate();
}*/
/*
function init() {
	m_debug_func = updateCandidates

	//TOREFACT
	m_models_values["doma"] = new ModelInfo("doma" ,"doma-interior_meshed_tex.png", "doma-interior_meshed_simplified", 11.62, -0.137, 17.99, -1)
	m_models_values["pedret"] = new ModelInfo("pedret" ,"pedret-interior_meshed_tex.png", "pedret-interior_meshed_simplified", 2.51, 0.119, -7.99,-1)
	m_models_values["solsona"] = new ModelInfo("solsona" ,"solsona_meshed_tex.jpg", "solsona_meshed_simplified", 6.73, 0.54, 16.89,-1)
	

	m_container = document.createElement( 'div' );
	document.body.appendChild( m_container );
	

	m_current_sprites_in_scene = new THREE.Group();
	m_current_sprites_in_scene.name = "imageCollectionGroup"
	m_current_sprites_in_scene.position.z = -4
	
	m_scene = new THREE.Scene();
	m_scene.background = new THREE.Color( 0x72645b );
	m_scene.fog = new THREE.Fog( 0x72645b, 2, 15 );

	m_scene_collections = new THREE.Scene();
	m_scene_collections.add(m_current_sprites_in_scene);
	m_scene_collections.background = null;

	m_scene_capture = new THREE.Scene();

	m_renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
	m_renderer.setPixelRatio( window.devicePixelRatio );
	m_renderer.setSize( window.innerWidth, window.innerHeight );
	m_renderer.outputEncoding = THREE.sRGBEncoding;
	m_renderer.setClearColor(0xffffff, 0);
	m_renderer.autoClear = false; 

	m_renderer.xr.enabled = true;
	m_renderer.xr.setReferenceSpaceType( 'local' );
	m_renderer.setAnimationLoop( loop );

	//TOREFACT
	m_render_target_secondary = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

	//TOREFACT
	m_views[1].height = 0.3
	m_views[1].width = (m_views[1].height*(window.innerWidth / window.innerHeight))*(1/(window.innerWidth / window.innerHeight))
	m_views[1].left = 1.0-m_views[1].width

	m_container.appendChild( m_renderer.domElement );


	document.body.appendChild( VRButton.createButton( m_renderer) );
	
	m_gui = new Gui();

	

	m_selection_rectangle.selectionBox = new SelectionBox( m_camera, m_scene );
	m_selection_rectangle.helper = new SelectionHelper( m_selection_rectangle.selectionBox, m_renderer, 'selectBox' );
	m_selection_rectangle.helper.element.hidden = true;






	window.addEventListener( 'resize', onWindowResize );
	
	document.addEventListener( 'mousewheel', onDocumentMouseWheel );
	document.addEventListener( 'pointerup', onDocumentPointerUp );
	document.addEventListener('pointermove', onDocumentPointerMove)
	document.addEventListener( 'pointerdown', onDocumentPointerDown );
	document.addEventListener("keydown", onDocumentKeyDown, false);
	document.addEventListener("keyup", event => {
	  if (event.isComposing || event.keyCode === 17 && !m_application_state.views_swaped) {
	    m_gui.enableGui()
	    m_application_state.select_controls_enabled = false;
		m_dragging = false

	    m_controls.enabled = true;

	    m_selection_rectangle.helper.element.hidden = true;

	  }
	});

	//TOREFACT
	m_manager.onLoad = function()
	{
		//m_renderer.render( m_scene, camera );
	    console.log("INFO: DOMA_TEXTURE_LOADED");
	    animate()
	    
		m_application_state.textures_loaded = true
	}
	
	loadShaders()
	
}
function loadShaders()
{
	function onLoadShader()
	{
		m_application_state.num_shaders_loaded +=1
	}
	m_application_state.num_shaders_loaded = 0
	var shaderLoader = new THREE.FileLoader();
	shaderLoader.load('assets/shaders/captureImage.frag',function ( data ) {m_shaders.captureImageFrag =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/scene.frag',function ( data ) {m_shaders.sceneFrag =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/scene.vert',function ( data ) {m_shaders.sceneVert =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/screen.frag',function ( data ) {m_shaders.screenFrag =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/sprite.vert',function ( data ) {m_shaders.spriteVert =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/sprite.frag',function ( data ) {m_shaders.spriteFrag =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/spriteSquared.vert',function ( data ) {m_shaders.spriteSquaredVert =  data; onLoadShader(); },);
	shaderLoader.load('assets/shaders/spriteSquared.frag',function ( data ) {m_shaders.spriteSquaredFrag =  data; onLoadShader(); },);
}
function onWindowResize() {

	m_camera.aspect = window.innerWidth / window.innerHeight;
	m_camera.updateProjectionMatrix();

	m_renderer.setSize( window.innerWidth, window.innerHeight );



	m_views[1].height = 0.3
	m_views[1].width = (m_views[1].height*(window.innerWidth / window.innerHeight))*(1/(window.innerWidth / window.innerHeight))
	m_views[1].left = 1.0-m_views[1].width


	m_camera_capture_orto.left = window.innerWidth / - 2;
	m_camera_capture_orto.right =window.innerWidth / 2;
	m_camera_capture_orto.top = window.innerHeight / 2;
	m_camera_capture_orto.bottom = window.innerHeight / - 2;
	m_camera_capture_orto.updateProjectionMatrix();

	m_camera_collections.left = window.innerWidth / - 2;
	m_camera_collections.right =window.innerWidth / 2;
	m_camera_collections.top = window.innerHeight / 2;
	m_camera_collections.bottom = window.innerHeight / - 2;
	m_camera_collections.updateProjectionMatrix();
	showCollections(false)

}
*/
/*function updateVR(delta)
{

	m_VRControls.update(delta)

}
function exitVR()
{
	m_vr_move_utils.lastFrameInVR = false

	//m_vr_panels_group.remove( m_current_sprites_in_scene );
	m_scene_collections.add(m_current_sprites_in_scene);
	resetCamera("ORBIT");
	showCollections(false)
	
}
function enterVR()
{
	//m_vr_panels_group.add(m_current_sprites_in_scene );
	m_scene_collections.remove(m_current_sprites_in_scene);
	m_vr_move_utils.lastFrameInVR = true
	resetCamera("NULL");
	m_camera_group.position.x = m_models_values[m_gui.gui_options.current_model].pos_x_cam_start
	m_camera_group.position.z = m_models_values[m_gui.gui_options.current_model].pos_z_cam_start
	m_camera_group.position.y = m_models_values[m_gui.gui_options.current_model].vr_y+1
	showCollections(false)
	
}*/
/*function update()
{

	const timer = Date.now() * 0.0005;
	const delta = m_clock.getDelta();
	requestAnimationFrame( animate );

	switch(m_application_state.state)
	{
		case AppStates.READY_TO_GO:
		{	
			if(m_recording_state==1)
			{

				m_recording_distance += m_old_pos_cam.distanceTo(m_camera.position);
				m_recording_timer += delta;

			}
			var changeModel = m_gui.update()
			if(changeModel)
			{
				startSceneForModel()
				return
			}

			if(m_renderer.xr.isPresenting)
			{
				if(m_gui.checkViewChanged)
				{
					if(m_gui.gui_options.show_view_enabled)
					{
						if(m_plane_render_target)
							m_vr_panels_group.add(m_plane_render_target);
					}
					else
					{
						if(m_plane_render_target)
							m_vr_panels_group.remove(m_plane_render_target);
					}
					
					m_gui.checkViewChanged = false
				}
				
				if(!m_vr_move_utils.lastFrameInVR)
					enterVR()
				updateVR(delta)
			}
			else if(m_vr_move_utils.lastFrameInVR)
			{
				exitVR()
			} 
			m_vr_panels_group.visible = m_renderer.xr.isPresenting;
			
			updateCollectionsAnims(delta)
			if(m_application_state.need_to_update_auto_detect)
				m_timer_update += delta

			if(!m_renderer.xr.isPresenting && m_old_pos_cam.distanceTo(m_camera.position) > 0.0001)
			{
				//console.log("changed!! " + m_old_pos_cam.x + " " +m_camera.position.x)
				m_timer_update = 0;
				m_application_state.need_to_update_auto_detect = true;
				if(m_gui.gui_options.auto_score_enabled)
					setCollectionOpacity(0.2);
			}
				
			
			if(m_camera_mode != "FLY")
			{
				if(m_controls)
					m_controls.update();
				if(m_controls_secondary)
					m_controls_secondary.update();
			}
				
			//m_stats.update();
			if(m_timer_update > m_gui.gui_options.timer_recalc)
			{
				//console.log("update")
				m_application_state.need_to_update_auto_detect = false
				m_timer_update = 0
				if(m_gui.gui_options.auto_score_enabled)
					updateCandidates(false);
				else
					setCollectionOpacity(1.0);
			}
			if(m_camera_mode == "FLY")
			{
				m_controls.movementSpeed = 0.33 * 1;
				m_controls.update( delta );
			}
			m_old_pos_cam.copy(m_camera.position);

			m_scene_models[0].material.uniforms.showRedArea.value = m_gui.gui_options.red_area_enabled;
			break
		}


		case AppStates.THREE_JS_INIT:
		{
			if(m_application_state.num_shaders_loaded == NUM_SHADERS_TO_LOAD)
			{
				startSceneForModel();
				m_application_state.state = AppStates.THREE_JS_INIT_SHADERS
			}
			break
		}
		case AppStates.THREE_JS_INIT_SHADERS:
		{
			if(m_application_state.three_js_inited)
			{
				m_application_state.state = AppStates.LOADING_MESHES
			}
			break
		}
		case AppStates.LOADING_MESHES:
		{
			if(m_application_state.num_models_loaded == m_application_state.num_models_to_load 
				&& m_application_state.num_cameras_loaded == m_application_state.num_cameras_to_load
				&& m_VRControls.isLoaded()
				)
			{
				document.getElementById("loadingText").innerHTML = "Loading: 80%";
				m_application_state.state = AppStates.LOADING_TEXTURES
			}
			break
		}
		case AppStates.LOADING_TEXTURES:
		{
			if(m_application_state.textures_loaded)
			{

				m_application_state.state = AppStates.LOADING_PRECOMPUTED_DATA
				var loader = new THREE.FileLoader();
		        loader.load('models/'+m_models_values[m_gui.gui_options.current_model].path+'/capture_info/precomputedCameraData.txt', function ( data ) {
				        // output the text to the console
				        m_capture_rays_need_recomputation = DataLoader.loadPrecomputedFile(data, m_camera_list)
				        m_application_state.precomputed_file_loaded = true
						document.getElementById("loadingText").innerHTML = "Loading: 90%";
				});
				
			}
			break
		}
		case AppStates.LOADING_PRECOMPUTED_DATA:
		{
			if(m_application_state.precomputed_file_loaded)
			{
				if(m_capture_rays_need_recomputation)
				{
					
					precomputeCaptureInfo(m_num_rays_precomputation,m_num_rays_precomputation,m_application_state.count_precomputation_iterations)
				}
				else
				{
					m_gui.enableGui()
					m_application_state.state = AppStates.READY_TO_GO
					document.getElementById("loadingText").innerHTML = "";
					document.getElementById("loadingTextContainer").style.visibility = "hidden";
					console.log("INFO: System ready to go!")
				}
				
			}
				
			break
		}
	}
}
function loop()
{
	update();
	render();
}
function animate() {
	
	//m_renderer.setAnimationLoop( loop );

}*/
/*function renderMainCamera(view_index, draw_border)
{

	if(m_plane_image_secondary != null)
		m_plane_image_secondary.material.uniforms.showTexture.value = m_gui.gui_options.show_photo_enabled && m_gui.gui_options.show_view_enabled && m_gui.gui_options.show_camera_enabled;
	
	const left = Math.floor( window.innerWidth * m_views[view_index].left );
	const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
	const width = Math.floor( window.innerWidth * m_views[view_index].width );
	const height = Math.floor( window.innerHeight * m_views[view_index].height );

	if(!m_renderer.xr.isPresenting)
	{
		m_renderer.setViewport( left, bottom, width, height );
		m_renderer.setScissor( left, bottom, width, height );
		m_renderer.setScissorTest( true );


	} else
	{
		m_renderer.setScissorTest( false );

	}

	if(draw_border)
	{
		m_renderer.setClearColor ( new THREE.Color(0x000000), 1.0 )
		m_renderer.clear();
		m_renderer.setViewport( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
		m_renderer.setScissor( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
	}
	m_camera.aspect = width / height;
	m_camera.updateProjectionMatrix();
	m_cameraHelper.visible = m_gui.gui_options.show_camera_enabled;
	m_renderer.render( m_scene, m_camera );
}*/
/*function renderSecondaryCamera(view_index, draw_border)
{

	m_cameraHelper.visible = false;
	const left = Math.floor( window.innerWidth * m_views[view_index].left );
	const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
	const width = Math.floor( window.innerWidth * m_views[view_index].width );
	const height = Math.floor( window.innerHeight * m_views[view_index].height );

	

	if(m_plane_image_secondary != null)
	{
		
		m_plane_image_secondary.material.uniforms.showTexture.value = m_gui.gui_options.show_photo_enabled;

		var frustumHeight = 2 * m_camera_capture.near * Math.tan(THREE.Math.degToRad( m_camera_capture.fov * 0.5 ));
		var frustumWidth = frustumHeight * m_camera_capture.aspect;
		m_plane_image_secondary.scale.x = frustumWidth;
		m_plane_image_secondary.scale.y = frustumHeight;
		m_renderer.xr.enabled = false;
		
		if(m_changed_image_in_view >= 1)
		{
			if(m_changed_image_in_view >=1)
				m_changed_image_in_view = 0
			//m_changed_image_in_view = m_changed_image_in_view +1
			var old_rt = m_renderer.getRenderTarget()
			m_renderer.setRenderTarget(m_render_target_secondary)
			//m_camera_capture.aspect = width / height;
			m_camera_capture.updateProjectionMatrix();
			var aux = false
			if(m_vr_panels_group)
			{
				aux = m_vr_panels_group.visible 
				m_vr_panels_group.visible = false
			}
			

			m_renderer.render( m_scene, m_camera_capture );
			console.log("INFO: Draw capture to render target")
			

			if(m_vr_panels_group)
			{
				m_vr_panels_group.visible = aux
			}
			m_renderer.setRenderTarget(null)
			m_renderer.xr.enabled = true;
			
		}
		
		
		if(m_renderer.xr.isPresenting)
		{
			m_plane_render_target.scale.x = 2*m_camera_capture.aspect
			m_plane_render_target.scale.y = 2
			
		}
		else
		{
			m_plane_render_target.scale.x = window.innerHeight*m_camera_capture.aspect
			m_plane_render_target.scale.y = window.innerHeight

		}

	}
	if(m_renderer.xr.isPresenting)
	{
		return;
	}
	
	if(draw_border)
	{
		m_renderer.setViewport( left-0.1, bottom, width+0.1, height+0.1 );
		m_renderer.setScissor( left-0.1, bottom, width+0.1, height+0.1 );
		m_renderer.setScissorTest( true );
	}
	m_renderer.setViewport( left, bottom, width, height );
	m_renderer.setScissor( left, bottom, width, height );
	m_renderer.setScissorTest( true );
	

	if(draw_border)
	{
		m_renderer.setClearColor ( new THREE.Color(0x000000), 1.0 )
		m_renderer.clear();
		m_renderer.setViewport( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
		m_renderer.setScissor( left+m_views[view_index].border_size, bottom+m_views[view_index].border_size, width-m_views[view_index].border_size*2, height-m_views[view_index].border_size*2 );
	}
	if(m_plane_image_secondary != null)
	{
		m_renderer.render( m_scene_capture, m_camera_capture_orto );
	}
}*/
/*function renderClusters(view_index)
{
	if(m_renderer.xr.isPresenting)
		return;
	m_renderer.clearDepth();
	const left = Math.floor( window.innerWidth * m_views[view_index].left );
	const bottom = Math.floor( window.innerHeight * m_views[view_index].bottom );
	const width = Math.floor( window.innerWidth * m_views[view_index].width );
	const height = Math.floor( window.innerHeight * m_views[view_index].height );

	m_renderer.setViewport( left, bottom, width, height );
	m_renderer.setScissor( left, bottom, width, height );
	m_renderer.render( m_scene_collections, m_camera_collections );
}*/
/*function render() {
	if(m_application_state.state != AppStates.READY_TO_GO)
		return;
	//if ( windowWidth != window.innerWidth || windowHeight != window.innerHeight ) {

	//	windowWidth = window.innerWidth;
	//	windowHeight = window.innerHeight;

	//m_renderer.setSize( window.innerWidth, window.innerHeight );

	//}
	m_cameraHelper.update();
	m_renderer.clear();
	if(m_scene_models.length >0)
		m_scene_models[0].material.uniforms.projectCapture.value = m_gui.gui_options.project_capture_enabled && m_plane_image_secondary != null;
	if(m_gui.gui_options.show_view_enabled && !m_application_state.select_controls_enabled)
	{
		if(m_application_state.views_swaped)
		{
			renderSecondaryCamera(0, false);
			renderMainCamera(1, true);
		}
		else
		{
			renderMainCamera(0, false);
			renderSecondaryCamera(1, true);
		}
	}
	else
	{
		if(m_application_state.views_swaped)
		{
			renderSecondaryCamera(2, false);
		}
		else
		{
			renderMainCamera(2, false);
		}
	}

	if(!m_application_state.select_controls_enabled && (m_gui.gui_options.show_photo_collection || m_renderer.xr.isPresenting))
		renderClusters(2);
	

}*/
/*function precomputeCaptureInfo(rays_x, rays_y, iteration)
{
	

	DataLoader.precomputeRays(m_camera_list, rays_x, rays_y, iteration);
	m_application_state.count_precomputation_iterations = m_application_state.count_precomputation_iterations +1
	if(m_application_state.count_precomputation_iterations == m_camera_list.length)
	{
		m_capture_rays_need_recomputation = false
		DataLoader.precomputeCaptureSimilitude(m_camera_list);
		DataLoader.savePrecomputedFile(m_camera_list)
		m_application_state.precomputation_done = true
		m_application_state.count_precomputation_iterations = 0
	}
	
}*/


</script>

		
	</body>
</html>
