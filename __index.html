<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - ball shooter</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<script src="modules/FileSaver.js"></script>
		<div id="info">
			3D view
		</div>
		<div id="info2">
			2D view
		</div>
		<div class=container4 id="loadingTextContainer">
		  <p id="loadingText">Loading: 0% 
		</div>
<script id="vertexShaderSprite" type="x-shader/x-fragment">
			varying vec2 vUv;

		    void main() {
		    	vUv = uv;
		      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);

		    }
		</script>

		<script id="fragmentShaderSprite" type="x-shader/x-fragment">
			uniform vec2 minSel; 
			uniform vec2 maxSel; 
			uniform sampler2D texture1;
			uniform float opacity;

			varying vec2 vUv;
			float borderSel = 0.015;
			void main() {

				if(vUv.x > 0.98 || vUv.x < 0.02 || vUv.y > 0.98 || vUv.y < 0.02)
				{
					gl_FragColor = vec4(0.0,0.0,0.0,1.0);
				}
				else
				{
					vec4 color;
					if(minSel != maxSel && (
						(vUv.x > minSel.x && vUv.x < minSel.x+borderSel && vUv.y > minSel.y && vUv.y < maxSel.y+borderSel) ||
						(vUv.y > minSel.y && vUv.y < minSel.y+borderSel && vUv.x > minSel.x && vUv.x < maxSel.x+borderSel) ||
						(vUv.x > maxSel.x && vUv.x < maxSel.x+borderSel && vUv.y > minSel.y && vUv.y < maxSel.y+borderSel) ||
						(vUv.y > maxSel.y && vUv.y < maxSel.y+borderSel && vUv.x > minSel.x && vUv.x < maxSel.x+borderSel)
						))
					{
						color = vec4(1.0,0.0,0.0,1.0);
					}
					else
					{
						color = texture2D(texture1, vUv); 
						
					}
					color.a = opacity;
					gl_FragColor = color;
					
				}
			}
		</script>
		<script id="vertexShaderScene" type="x-shader/x-fragment">
			varying vec2 vUv; 
		    varying vec3 capturePos;
		    varying vec4 modelViewPosition; 
		    varying vec3 vecNormal;
		    uniform mat4 viewMatrixCapture;
		    uniform mat4 projectionMatrixCapture;

		    void main() {
		    	vUv = uv;
		    	vec4 auxCapture = projectionMatrixCapture * viewMatrixCapture * modelMatrix* vec4(position,1.0);
		    	capturePos = vec3(auxCapture.x/auxCapture.w,auxCapture.y/auxCapture.w,auxCapture.z/auxCapture.w);
		    	//capturePos =   (projectionMatrixCapture *  modelViewMatrix * vec4(position,1.0)).xyz;
		      //vUv = position; 
		      //vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
		      //vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz; //????????
		      //gl_Position = projectionMatrix * modelViewPosition; 
		      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);
		      
		      //gl_Position = capturePos;
		    }
		</script>
		<script id="fragmentShaderScreen" type="x-shader/x-fragment">

			varying vec2 vUv;
			uniform sampler2D tDiffuse;

			void main() {

				gl_FragColor = texture2D( tDiffuse, vUv );

			}

		</script>
		<script id="fragmentShaderCaptureImage" type="x-shader/x-fragment">
			uniform sampler2D texture1;
			uniform bool showTexture;

			varying vec2 vUv;
			varying vec3 capturePos;
			void main() {
			  //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			  //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  if(showTexture && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0)
			  {
			  		vec2 texCoords = vec2((capturePos.x+1.0f)/2.0f,(capturePos.y+1.0f)/2.0f);
			  		gl_FragColor = texture2D(texture1, texCoords);
			  }
			  else 
			  {
			  	discard;
					//gl_FragColor = texture2D(texture1, vUv); 
					//discard;
			  }

			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform sampler2D texture1;
			uniform sampler2D texture2;
			uniform bool showRedArea;
			uniform bool projectCapture;
			varying vec2 vUv;
			varying vec3 capturePos;
			void main() {
			  //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			  //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  if(showRedArea && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  {

			  	if(capturePos.x < -0.95 || capturePos.x > 0.95 || capturePos.y < -0.95 || capturePos.y > 0.95)
			  		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.6), 1.0);
			  	else
			  		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.8), 1.0);
			  }
			  else 
			  {
			  	if(projectCapture && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			  	{
			  		vec2 texCoords = vec2((capturePos.x+1.0f)/2.0f,(capturePos.y+1.0f)/2.0f);
			  		gl_FragColor = texture2D(texture2, texCoords);
			  	}
			  	else
			  	{
			  		gl_FragColor = texture2D(texture1, vUv); 
			  	}
					
					//discard;
			  }

			  
			   
			}
		</script>
		<script type="module">

			import * as THREE from '../build/three.module.js';

import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { PLYLoader } from './jsm/loaders/PLYLoader.js';

			import { OrbitControls } from './jsm/controls/CustomOrbitControls.js';
			//import { FlyControls } from './jsm/controls/FlyControls.js';
			//import { TrackballControls } from './jsm/controls/CustomTrackballControls.js';
			import { SelectionBox } from './jsm/interactive/SelectionBox.js';
			import { SelectionHelper } from './jsm/interactive/SelectionHelper.js';
			import { BoxLineGeometry } from './jsm/geometries/BoxLineGeometry.js';
			import { VRButton } from './jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from './jsm/webxr/XRControllerModelFactory.js';

			let camera, scene, renderer, m_camera_capture;
let m_container, m_stats, m_gui;
			let room;

			let count = 0;
			const radius = 0.08;
			let normal = new THREE.Vector3();
			const relativeVelocity = new THREE.Vector3();

			const clock = new THREE.Clock();


			const AppStates =
			{
				THREE_JS_INIT: "init_state",
				LOADING_MESHES: "loading_meshes_state",
				LOADING_TEXTURES: "loading_textures_state",
				LOADING_PRECOMPUTED_DATA: "loading_precomputed_state",
				READY_TO_GO: "ready_state",

			}
			var m_camera_list = [];
			var m_camera_mesh_list = [];
			var m_scene_models = [];
			var m_current_candidates = [];
			var m_current_candidates_collections = [];

			var m_controls;
			var m_controls_secondary;
			var m_camera_mode = "ORBIT";
			var m_timer_update = 0;
			var m_cams_enabled = false;
			var m_current_capture_in_view_index = -1;
			var m_capture_rays_need_recomputation = true;

			const m_num_rays_precomputation = 10;	//rays x rays
			var m_dragging = false;
			var m_current_sprites_in_scene = [];
			var m_selection_rectangle = {
				startNDC: null,
				endNDC: null,
				startWorld: null,
				endWorld: null,
				selectionBox: null,
				helper: null,
			}
			var m_has_any_secondary_capture = false;
			var m_min_pos = null;
			var m_max_pos = null;
			var m_plane_image_secondary = null;
			var m_plane_render_target = null;
			var m_render_target_secondary = null;
			var m_application_state = 
			{
				state: AppStates.THREE_JS_INIT,
				num_cameras_loaded: 0,
				num_models_loaded: 0,
				three_js_inited: false,
				num_cameras_to_load: 0,
				num_models_to_load: 0,
				precomputed_file_loaded: false,
				precomputation_done: false,
				textures_loaded: false,
				count_precomputation_iterations: 0,
				capture_index_over_mouse: -1,
				transition_animation_step: 1.0,
				views_swaped: false,
				select_controls_enabled: false,
				need_to_update_auto_detect: true,
			}
			var m_debug = 
			{
				debug_mesh_lines: [],
			}

			const m_models_values = []
			m_models_values["doma"] ={
				path: "doma", 
				texture_name: "doma-interior_texture16k.jpg",
				mesh_name: "doma-interior_textured.ply",
				pos_x_cam_start: 11*0.03,
				pos_y_cam_start: -20*0.03,
				pos_z_cam_start: 2*0.03,
			}
			m_models_values["pedret"] ={
				path: "pedret", 
				texture_name: "pedret-interior_meshed_tex.png",
				mesh_name: "pedret-interior_meshed_simplified.ply",
				pos_x_cam_start: 0.0681,
				pos_y_cam_start: 0.0920,
				pos_z_cam_start: 0.0327,
			}
			m_models_values["solsona"] ={
				path: "solsona", 
				texture_name: "solsona_meshed_tex.jpg",
				mesh_name: "solsona_meshed_simplified.ply",
				pos_x_cam_start: 0.329,
				pos_y_cam_start: -0.545,
				pos_z_cam_start: 0.0307,
			}
			/*var m_canvas = new fabric.Canvas('canvas');

			m_canvas.setHeight(0);
			m_canvas.setWidth(0);
			m_canvas.renderAll();
			m_canvas.renderAll.bind(m_canvas)();
			m_canvas.backgroundColor = null;*/

			const m_views = [
				{
					left: 0.0,
					bottom: 0.0,
					width: 1.0,
					height: 1.0,
					border_size: 2.0,
				},
				{
					left: 0.0,
					bottom: 0.0,
					width: 0.0,
					height: 0.0,
					border_size: 2.0,
				},
				{
					left: 0.0,
					bottom: 0.0,
					width: 1.0,
					height: 1.0,
					border_size: 2.0,
				}
			];
			var m_gui_options =
			{
				projection: 0,
				orientation: 5,
				position: 1,
				timer_recalc: 1,

				max_num_collections: 7,
				max_collection_size: 5,
				similitude_treshold: 0.7,
				discard_too_similar: true,
				clustering_method: 'normal',
				linkage_enabled: true,

				red_area_enabled: false,
				show_camera_enabled: false,
				show_view_enabled: false,
				show_photo_enabled: false,
				project_capture_enabled: false,
				auto_score_enabled: false,

				current_model: "pedret",

			}

			init();
			animate();

			function init() {
m_container = document.createElement( 'div' );
				//const canvas = document.getElementById( 'canvas' );
				//canvas.width = 300 * window.devicePixelRatio;
				//canvas.height = 300 * window.devicePixelRatio;
				//const context = canvas.getContext( '2d' );
				document.body.appendChild( m_container );
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x505050 );

var start_x = m_models_values[m_gui_options.current_model].pos_x_cam_start
				var start_y = m_models_values[m_gui_options.current_model].pos_y_cam_start
				var start_z = m_models_values[m_gui_options.current_model].pos_z_cam_start

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.01, 10 );
				//camera.position.set( 0, 1.6, 3 );
camera.position.set( start_x,start_y+1,start_z );

camera.name = "main_camera"
				camera.up.set(0,0,-1);
				room = new THREE.LineSegments(
					new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ),
					new THREE.LineBasicMaterial( { color: 0x808080 } )
				);
				room.geometry.translate( 0, 3, 0 );
				scene.add( room );

				m_camera_capture = new THREE.PerspectiveCamera( 50.5, 4000 / 2950, 0.01, 10 );
				m_camera_capture.position.set( start_x,start_y,start_z );
				/*m_cameraHelper = new THREE.CameraHelper(m_camera_capture);
				scene.add(m_cameraHelper);*/

				const geometry = new THREE.IcosahedronGeometry( radius, 3 );

				for ( let i = 0; i < 200; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

					object.position.x = Math.random() * 4 - 2;
					object.position.y = Math.random() * 4;
					object.position.z = Math.random() * 4 - 2;

					object.userData.velocity = new THREE.Vector3();
					object.userData.velocity.x = Math.random() * 0.01 - 0.005;
					object.userData.velocity.y = Math.random() * 0.01 - 0.005;
					object.userData.velocity.z = Math.random() * 0.01 - 0.005;

					room.add( object );

				}

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				//document.body.appendChild( renderer.domElement );
				m_container.appendChild( renderer.domElement );
				//

				document.body.appendChild( VRButton.createButton( renderer ) );

				// controllers


				window.addEventListener( 'resize', onWindowResize );

				m_stats = new Stats();
				m_container.appendChild( m_stats.dom );
				document.body.appendChild( VRButton.createButton( renderer ) );
				createGUI();
			}

function createGUI()
			{
				// expressions

				m_gui = new GUI();

				const models = [ 'pedret', 'doma','solsona'];

				const modelsFolder = m_gui.addFolder( 'Models' );

				modelsFolder.add( m_gui_options, 'current_model' ).options( models ).name( 'Current model' ).onChange( function () {
					startSceneForModel();
				} );

				modelsFolder.open();

				const scoreFolder = m_gui.addFolder( 'Score computation' );


				scoreFolder.add(m_gui_options, 'projection', 0, 10, 0.1 ).name( 'Projection' );
				scoreFolder.add(m_gui_options, 'position', 0, 10, 0.1 ).name( 'Position' );
				scoreFolder.add(m_gui_options, 'orientation', 0, 10, 0.1 ).name( 'Orientation' );
				scoreFolder.add(m_gui_options, 'timer_recalc', 0, 10, 0.1 ).name( 'Recalc timer' );

				scoreFolder.open();

				const viewFolder = m_gui.addFolder( 'Display options' );


				viewFolder.add(m_gui_options, 'red_area_enabled').name( 'Show area' );
				viewFolder.add(m_gui_options, 'show_camera_enabled').name( 'Show camera' );
				viewFolder.add(m_gui_options, 'show_photo_enabled').name( 'Show photo' );
				viewFolder.add(m_gui_options, 'project_capture_enabled').name( 'Show projection' );
				viewFolder.add(m_gui_options, 'show_view_enabled').name( 'Show view' ).onChange(function ()
					{
						if(m_gui_options.show_view_enabled)
						{
							document.getElementById("info2").style.visibility = "visible";
						}
						else
						{
							document.getElementById("info2").style.visibility = "hidden";
						}
					});
				viewFolder.add(m_gui_options, 'auto_score_enabled').name( 'Auto-detect' );
				viewFolder.open();


				const candidatesFolder = m_gui.addFolder( 'Candidate selection' );

				const clustering_methods = [ 'normal', 'single_linkage'];

				candidatesFolder.add(m_gui_options, 'max_num_collections', 0, 20, 1 ).name( 'Max num collection' );
				candidatesFolder.add(m_gui_options, 'max_collection_size', 0, 20, 1 ).name( 'Max size collection' );
				candidatesFolder.add(m_gui_options, 'similitude_treshold', 0, 1, 0.01 ).name( 'Similitude treshold' );
				//candidatesFolder.add(m_gui_options, 'linkage_enabled').name( 'Linkage clustering' );
				candidatesFolder.add( m_gui_options, 'clustering_method' ).options( clustering_methods ).name( 'Cluster method' );
				candidatesFolder.open();




				//const clusterMethodFolder = m_gui.addFolder( 'Cluster method' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			//

			function animate() {

				renderer.setAnimationLoop( render );

			}

			function render() {
				m_stats.update();

				//

				const delta = clock.getDelta() * 0.8; // slow down simulation

				const range = 3 - radius;

				for ( let i = 0; i < room.children.length; i ++ ) {

					const object = room.children[ i ];

					object.position.x += object.userData.velocity.x * delta;
					object.position.y += object.userData.velocity.y * delta;
					object.position.z += object.userData.velocity.z * delta;

					// keep objects inside room

					if ( object.position.x < - range || object.position.x > range ) {

						object.position.x = THREE.MathUtils.clamp( object.position.x, - range, range );
						object.userData.velocity.x = - object.userData.velocity.x;

					}

					if ( object.position.y < radius || object.position.y > 6 ) {

						object.position.y = Math.max( object.position.y, radius );

						object.userData.velocity.x *= 0.98;
						object.userData.velocity.y = - object.userData.velocity.y * 0.8;
						object.userData.velocity.z *= 0.98;

					}

					if ( object.position.z < - range || object.position.z > range ) {

						object.position.z = THREE.MathUtils.clamp( object.position.z, - range, range );
						object.userData.velocity.z = - object.userData.velocity.z;

					}

					for ( let j = i + 1; j < room.children.length; j ++ ) {

						const object2 = room.children[ j ];

						normal.copy( object.position ).sub( object2.position );

						const distance = normal.length();

						if ( distance < 2 * radius ) {

							normal.multiplyScalar( 0.5 * distance - radius );

							object.position.sub( normal );
							object2.position.add( normal );

							normal.normalize();

							relativeVelocity.copy( object.userData.velocity ).sub( object2.userData.velocity );

							normal = normal.multiplyScalar( relativeVelocity.dot( normal ) );

							object.userData.velocity.sub( normal );
							object2.userData.velocity.add( normal );

						}

					}

					object.userData.velocity.y -= 9.8 * delta;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>