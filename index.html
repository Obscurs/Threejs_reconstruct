<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - PLY</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

		<style>
			.selectBox {
				border: 1px solid #55aaff;
				background-color: rgba(75, 160, 255, 0.3);
				position: fixed;
			}
			div.container4 {
			    height: 100vh;
			    width: 100%;
			    position: absolute }
			div.container4 p {
			    margin: 0;
			    position: absolute;
			    top: 50%;
			    left: 50%;
			    margin-right: -50%;
			    font-size:40px;
			    transform: translate(-50%, -50%) }
		</style>

	</head>
	<body>
				<!--script src="scripts/shaders.js"--></script>
		<script src="modules/FileSaver.js"></script>
		<div id="selection_menu" style="position: absolute; text-align: center; width: 100%;">
			<!--<img id="captureImage" src="images/0001.jpg" style="visibility:hidden" alt="Image" height="200">-->
			<!--<img id="captureImage5" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="50" align="top" onclick="selectCapture(5)"-->
			<!--<img id="captureImage3" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="100" align="top" onclick="selectCapture(3)"-->
			<!--<img id="captureImage1" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="150" align="top" onclick="selectCapture(1)"-->
			<!--<img id="captureImage0" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="200" align="top" onclick="selectCapture(0)"-->
			<!--<img id="captureImage2" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="150" align="top" onclick="selectCapture(2)"-->
			<!--<img id="captureImage4" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="100" align="top" onclick="selectCapture(4)"-->
			<!--<img id="captureImage6" src="captures/0001.jpg" alt="Image" style="border: 5px solid #555;" height="50" align="top" onclick="selectCapture(6)"-->
		</div>
		<div class=container4 id="loadingTextContainer">
		  <p id="loadingText">Loading: 0% 
		</div>
		<script>

			let m_container, m_stats, m_gui;

			let m_camera, m_camera_capture, m_scene, m_scene_collections, m_camera_collections, m_renderer, m_context;
			const AppStates =
			{
				THREE_JS_INIT: "init_state",
				LOADING_MESHES: "loading_meshes_state",
				LOADING_TEXTURES: "loading_textures_state",
				LOADING_PRECOMPUTED_DATA: "loading_precomputed_state",
				READY_TO_GO: "ready_state",

			}
			var m_camera_list = [];
			var m_camera_mesh_list = [];
			var m_scene_models = [];
			var m_current_candidates = [];
			var m_current_candidates_collections = [];

			var m_controls;
			var m_camera_mode = "ORBIT";
			var m_timer_update = 0;
			var m_cams_enabled = false;
			var m_need_to_update = true;
			var m_current_capture_in_view_index = -1;
			var m_capture_rays_need_recomputation = true;
			var m_testVec1;
			var m_testVec2;
			var m_num_rays_precomputation = 10;	//rays x rays
			var m_select_controls_enabled = false;
			var m_dragging = false;
			var m_captureShader;
			var m_current_sprites_in_scene = [];
			var m_selection_rectangle = {
				startNDC: null,
				endNDC: null,
				selectionBox: null,
				helper: null,
			}
			var m_min_pos = null;
			var m_max_pos = null;
			var m_application_state = 
			{
				state: AppStates.THREE_JS_INIT,
				num_cameras_loaded: 0,
				num_models_loaded: 0,
				three_js_inited: false,
				num_cameras_to_load: 0,
				num_models_to_load: 0,
				precomputed_file_loaded: false,
				precomputation_done: false,
				textures_loaded: false,
				count_precomputation_iterations: 0,
			}

			/*var m_canvas = new fabric.Canvas('canvas');

			m_canvas.setHeight(0);
			m_canvas.setWidth(0);
			m_canvas.renderAll();
			m_canvas.renderAll.bind(m_canvas)();
			m_canvas.backgroundColor = null;*/

			const m_views = [
				{
					left: 0.0,
					bottom: 0.0,
					width: 0.5,
					height: 1.0,
				},
				{
					left: 0.5,
					bottom: 0.0,
					width: 0.5,
					height: 0.5,
				},
				{
					left: 0.0,
					bottom: 0.0,
					width: 1.0,
					height: 1.0,
				}
			];
			var m_gui_options =
			{
				projection: 0,
				orientation: 5,
				position: 1,
				timer_recalc: 1,

				max_num_collections: 7,
				max_collection_size: 5,
				similitude_treshold: 0.7,

				red_area_enabled: false,
				show_camera_enabled: false,
				show_view_enabled: false,
				auto_score_enabled: false,
			}






		</script>
		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { PLYLoader } from './jsm/loaders/PLYLoader.js';

			import { OrbitControls } from './jsm/controls/CustomOrbitControls.js';
			import { FlyControls } from './jsm/controls/FlyControls.js';
			import { TrackballControls } from './jsm/controls/CustomTrackballControls.js';
			import { SelectionBox } from './jsm/interactive/SelectionBox.js';
			import { SelectionHelper } from './jsm/interactive/SelectionHelper.js';

			//import { saveAs } from './modules/FileSaver.js';

			const m_clock = new THREE.Clock();
			var m_cameraHelper;
			var m_manager = new THREE.LoadingManager();
			m_testVec1 = new THREE.Vector3();
			m_testVec2 = new THREE.Vector3();
			var m_old_pos_cam =  new THREE.Vector3();
			
			init();

			


			function createGUI()
			{
				// expressions

				m_gui = new GUI();
				const scoreFolder = m_gui.addFolder( 'Score computation' );


				scoreFolder.add(m_gui_options, 'projection', 0, 10, 0.1 ).name( 'Projection' );
				scoreFolder.add(m_gui_options, 'position', 0, 10, 0.1 ).name( 'Position' );
				scoreFolder.add(m_gui_options, 'orientation', 0, 10, 0.1 ).name( 'Orientation' );
				scoreFolder.add(m_gui_options, 'timer_recalc', 0, 10, 0.1 ).name( 'Recalc timer' );

				scoreFolder.open();

				const viewFolder = m_gui.addFolder( 'Display options' );


				viewFolder.add(m_gui_options, 'red_area_enabled').name( 'Show area' );
				viewFolder.add(m_gui_options, 'show_camera_enabled').name( 'Show camera' );
				viewFolder.add(m_gui_options, 'show_view_enabled').name( 'Show view' );
				viewFolder.add(m_gui_options, 'auto_score_enabled').name( 'Auto-detect' );
				viewFolder.open();

				const candidatesFolder = m_gui.addFolder( 'Candidate selection' );


				candidatesFolder.add(m_gui_options, 'max_num_collections', 0, 20, 1 ).name( 'Max num collection' );
				candidatesFolder.add(m_gui_options, 'max_collection_size', 0, 20, 1 ).name( 'Max size collection' );
				candidatesFolder.add(m_gui_options, 'similitude_treshold', 0, 1, 0.01 ).name( 'Similitude treshold' );

				candidatesFolder.open();

			}
			function moveToCapturePosition(index_capture)
			{
				var captureCam = m_camera_list[index_capture].mesh
				var direction = new THREE.Vector3();
				captureCam.getWorldDirection( direction );
				m_camera.position.copy( captureCam.position ).add( direction.multiplyScalar( 0.09 ) );
				
				var v1 = new THREE.Vector3(); // create once and reuse it
				m_controls.update()
				
				m_controls.target = new THREE.Vector3( captureCam.position.x, captureCam.position.y, captureCam.position.z );
				m_controls.update()
			}
			function changeCaptureInView(index_capture)
			{
				var directionCapture = new THREE.Vector3();
				var v1 = new THREE.Vector3();
				m_camera_list[index_capture].mesh.getWorldDirection( directionCapture );
				var positionCapture = new THREE.Vector3();
				positionCapture.copy(m_camera_list[index_capture].mesh.position);
				
				/*m_camera_capture.position.set( positionCapture.x,positionCapture.y,positionCapture.z );

				v1.copy( m_camera_list[index_capture].mesh.up ).applyQuaternion( m_camera_list[index_capture].mesh.quaternion );
				m_camera_capture.quaternion.copy( m_camera_list[index_capture].mesh.quaternion );
				m_camera_capture.up.set(v1.x, v1.y, v1.z); 
				*/

				m_camera_capture.copy(m_camera_list[index_capture].camera,true)


				//TODO: GET THIS VALUE FROM FILE:
				m_camera_capture.aspect = m_camera_list[index_capture].width / m_camera_list[index_capture].height;
				m_camera_capture.updateMatrixWorld();
				m_camera_capture.updateProjectionMatrix();
				var viewMat = new THREE.Matrix4();
				var projMat = new THREE.Matrix4();


				viewMat.copy(m_camera_capture.matrixWorldInverse);
				projMat.copy(m_camera_capture.projectionMatrix)
				m_scene_models[0].material.uniforms.viewMatrixCapture.value = viewMat;
				m_scene_models[0].material.uniforms.projectionMatrixCapture.value = projMat;
			}
			function selectCapture(index_capture)
			{
				//var index_capture = m_current_candidates[index_candidate].index;
				if(m_current_capture_in_view_index == index_capture)
				{
					moveToCapturePosition(index_capture)
				}
				else
				{
					changeCaptureInView(index_capture)
				}
				m_current_capture_in_view_index = index_capture;
				
			}
			function showCapture(indexCapture)
			{
				/*if(indexCapture != -1)
				{
					var source = "images/"+captureNames[indexCapture]

					document.getElementById('captureImage').src= source
					document.getElementById("captureImage").style.visibility = "visible";

					console.log(source)
				}*/
			}


			function showCollectionSprite(min_pos, max_pos, index_capture, order, sprites_to_remove)
			{

				var scale1 = (max_pos.x -min_pos.x)/m_camera_list[index_capture].width;
				var scale2 = (max_pos.y -min_pos.y)/m_camera_list[index_capture].height;
				var scale = Math.min(scale1, scale2);
				var sprite = m_camera_list[index_capture].sprite;
				var existing = m_scene_collections.getObjectByName(sprite.name);
				var _x = min_pos.x-window.innerWidth/2
				var _y = min_pos.y+window.innerHeight/2
				var spritepos = new THREE.Vector3(_x,_y,0);
				//var spritepos = new THREE.Vector3(0,0,1);

				sprite.center.set(0,1)
				sprite.scale.set(m_camera_list[index_capture].width*scale, m_camera_list[index_capture].height*scale, 1);
				sprite.position.set(spritepos.x,spritepos.y, spritepos.z);
				sprite.renderOrder = order;
				sprite.name = index_capture;
				

				m_scene_collections.add(sprite);

				m_current_sprites_in_scene.push(sprite)
				const index = sprites_to_remove.indexOf(sprite.name);
				if (index > -1) {
				  sprites_to_remove.splice(index, 1);
				}
					

				
			}
			function showCollection(min_pos, max_pos, index_collection, sprites_to_remove)
			{
				var currentOffset = new THREE.Vector2(5,5)
				var remaining_width = max_pos.x-min_pos.x-currentOffset.x;
				var remaining_height = max_pos.y-min_pos.y-currentOffset.y;
				var offset_per_image = 10;
				var num_elems = m_current_candidates_collections[index_collection].elems.length
				var width_image = remaining_width-num_elems*offset_per_image
				var height_image = remaining_height-num_elems*offset_per_image
				for(var i = num_elems-1; i >= 0; i--)
				{
					var min = new THREE.Vector2( min_pos.x+currentOffset.x, min_pos.y-currentOffset.y );
					var max = new THREE.Vector2( min_pos.x+currentOffset.x+width_image ,min_pos.y+currentOffset.y+height_image);
					currentOffset.x = currentOffset.x + offset_per_image;
					currentOffset.y = currentOffset.y + offset_per_image;
					showCollectionSprite(min, max, m_current_candidates_collections[index_collection].elems[i],num_elems-i,sprites_to_remove)
				}
				
			}

			function showCollections()
			{
				var remaining_width = window.innerWidth-200;
				var current_min_x = 0;
				var collection_height = 500
				var sprites_to_remove = []
				for(var i = 0; i < m_current_sprites_in_scene.length; i++)
				{
					sprites_to_remove.push(m_current_sprites_in_scene[i].name)
				}
				m_current_sprites_in_scene = []
				for(var i = 0; i < m_current_candidates_collections.length; i++)
				{
					var collection_width = remaining_width/4
					var min = new THREE.Vector2( current_min_x, 0 );
					var max = new THREE.Vector2(current_min_x+ collection_width,collection_height);
					showCollection(min,max,i, sprites_to_remove);
					remaining_width = remaining_width - collection_width;
					current_min_x = current_min_x + collection_width;
				}
				console.log(m_current_candidates_collections.length)
				console.log(sprites_to_remove)
				for(var i = 0; i < sprites_to_remove.length; i++)
				{
					var existing = m_scene_collections.getObjectByName(sprites_to_remove[i]);
					if(existing)
						m_scene_collections.remove( existing );

				}
			}
			function showCaptures(changed)
			{
				if(changed)
				{
					var arrayLength = m_camera_list.length;

					for (var i = 0; i < 7; i++) {
						var candidate = m_current_candidates[i]
						if(candidate)
						{
						    var source = "captures/"+m_camera_list[candidate.index].name

							document.getElementById('captureImage'+i).src= source
							document.getElementById("captureImage"+i).style.visibility = "visible";
						}
						

					}	
					//console.log(m_current_candidates)
				}
				

			}


			function onDocumentKeyDown(event) {
				if(m_application_state.state == AppStates.READY_TO_GO)
				{
					var keyCode = event.which;
				    if (keyCode == 82) { //R
				        resetCamera();
				    } else if (keyCode == 77) { //M
				        changeMode();
				    }  else if (keyCode == 67) { //C
				        toggleEnableCams();
				    }  else if (keyCode == 17) {
				    	m_select_controls_enabled = true;
				    	m_controls.enabled = false;

				    	m_selection_rectangle.helper.element.hidden = false;
				    	
				    	/*m_canvas.setHeight(window.innerHeight);
						m_canvas.setWidth(window.innerWidth);*/
				    }
				}
			};


			function vertexShader() {
			  return `
			    varying vec2 vUv; 
			    varying vec3 capturePos;
			    varying vec4 modelViewPosition; 
			    varying vec3 vecNormal;
			    uniform mat4 viewMatrixCapture;
			    uniform mat4 projectionMatrixCapture;

			    void main() {
			    	vUv = uv;
			    	vec4 auxCapture = projectionMatrixCapture * viewMatrixCapture * modelMatrix* vec4(position,1.0);
			    	capturePos = vec3(auxCapture.x/auxCapture.w,auxCapture.y/auxCapture.w,auxCapture.z/auxCapture.w);
			    	//capturePos =   (projectionMatrixCapture *  modelViewMatrix * vec4(position,1.0)).xyz;
			      //vUv = position; 
			      //vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
			      //vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz; //????????
			      //gl_Position = projectionMatrix * modelViewPosition; 
			      gl_Position =   projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);
			      
			      //gl_Position = capturePos;
			    }
			  `
			}

			function fragmentShader() {
			  return `
			      uniform vec3 colorA; 
			      uniform vec3 colorB; 
			      uniform sampler2D texture1;
			      uniform bool showRedArea;

			      varying vec2 vUv;
			      varying vec3 capturePos;
			      void main() {
			        //gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
			        //if(capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > 0.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			        if(showRedArea && capturePos.x > -1.0 && capturePos.x < 1.0 && capturePos.y > -1.0 && capturePos.y < 1.0 && capturePos.z > -1.0 && capturePos.z < 1.0)
			        {

			        	if(capturePos.x < -0.95 || capturePos.x > 0.95 || capturePos.y < -0.95 || capturePos.y > 0.95)
			        		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.6), 1.0);
			        	else
			        		gl_FragColor = vec4(mix(vec3(1.0,0.0,0.0), texture2D(texture1, vUv).xyz, 0.8), 1.0);
			        }
			        else 
			        {

						gl_FragColor = texture2D(texture1, vUv); 
						//discard;
			        }

			        
			         
			      }
			  `
			}
function onBeforeCompile( shader ) {

	// code based on: https://www.daniel-buckley.com/blog/2017/12/6/dev-diary-research-report-2d-sprite-outline-shaders

  var width = window.innerWidth;
  var height = window.innerHeight;

  shader.uniforms.outlineColor = { value: new THREE.Color(0x000000) };
  shader.uniforms.resolution = { value: new THREE.Vector2( width, height ) };

  shader.fragmentShader = 'uniform vec3 outlineColor;\n' + shader.fragmentShader;
  shader.fragmentShader = 'uniform vec2 resolution;\n' + shader.fragmentShader;
  console.log("HHHHH")
  shader.fragmentShader = shader.fragmentShader.replace(
    '#include <map_fragment>',
    [
      '#ifdef USE_MAP',

      '	vec4 texelColor = mapTexelToLinear( texture2D( map, vUv ) );',

      '	texelColor = mapTexelToLinear( texelColor );',

      ' if ( texelColor.a > 0.0 ) {',

      '		float a = 0.0f;',
	  '		if(vUv.x > 0.98 || vUv.x < 0.02 || vUv.y > 0.98 || vUv.y < 0.02)',
	  '			a = 0.0f;',
	  '		else',
	  '			a = 1.0f;',

      ' 	vec3 finalColor = mix( outlineColor, texelColor.rgb, a );',
      ' 	texelColor.rgb = finalColor;',

      ' }',

      '	diffuseColor *= texelColor;',

      '#endif'
    ].join( '\n' )
  );

  m_captureShader = shader;

}


			function onDocumentPointerMove(event)
			{
				if(!m_application_state.state == AppStates.READY_TO_GO)
				return;
				if(m_select_controls_enabled && m_dragging)
				{
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
				                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
				                                    0.5 );   
					m_selection_rectangle.endNDC = mouseNDC

					m_selection_rectangle.selectionBox.endPoint.set(
									( event.clientX / window.innerWidth ) * 2 - 1,
									- ( event.clientY / window.innerHeight ) * 2 + 1,
									0.5 );
				}
				else
				{

				}
			}
			function getCaptureUnderMouse(event)
			{
				event.preventDefault();
	            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );     
	            var raycaster =  new THREE.Raycaster();                                        
	           raycaster.setFromCamera( mouse3D, m_camera_collections );
	            var intersects = raycaster.intersectObjects( m_current_sprites_in_scene );
				//console.log(intersects)
				setDefaultColorsCameras();
	            if ( intersects.length > 0 ) 
	            	return intersects[ 0 ].object.name
	            else
	            	return -1
			}
			function getCollectionIndexUnderMouse(event)
			{

			}
			function onDocumentPointerDown(event)
			{
				if(!m_application_state.state == AppStates.READY_TO_GO)
				return;
				if(m_select_controls_enabled)
				{
					document.getElementById("selection_menu").style.display = "none";
					GUI.toggleHide();
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
				                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
				                                    0.5 );   
					
					m_selection_rectangle.startNDC = mouseNDC
					m_selection_rectangle.endNDC = mouseNDC
					console.log("NDC down" + mouseNDC);
					m_dragging = true;

					m_selection_rectangle.selectionBox.startPoint.set(
								( event.clientX / window.innerWidth ) * 2 - 1,
								- ( event.clientY / window.innerHeight ) * 2 + 1,
								0.5 );
				}
				else
				{
					
				}
			}

			function onDocumentPointerUp( event ) {   
				if(!m_application_state.state == AppStates.READY_TO_GO)
					return;
				if(m_select_controls_enabled)
				{
					document.getElementById("selection_menu").style.display = "block";
					GUI.toggleHide();
					m_dragging = false;
					var mouseNDC = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );   
					m_selection_rectangle.endNDC = mouseNDC
					//console.log("NDC up" + mouseNDC);

					m_selection_rectangle.selectionBox.endPoint.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1,
					0.5 );

					updateCandidates(true);
				}
				else
				{
					var captureIndex = getCaptureUnderMouse(event);
					if(captureIndex >= 0)
						selectCapture(captureIndex)
				}
				return;
				//console.log("pointer up")
				
				if(!m_cams_enabled || !m_application_state.state == AppStates.READY_TO_GO)
					return;
				if(m_camera_mode == "FLY")
					return;
				//console.log(m_camera_mode)
	            event.preventDefault();
	            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
	                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
	                                    0.5 );     
	            var raycaster =  new THREE.Raycaster();                                        
	           raycaster.setFromCamera( mouse3D, m_camera );
	            var intersects = raycaster.intersectObjects( m_camera_mesh_list );
				//console.log(intersects)
				setDefaultColorsCameras();
	            if ( intersects.length > 0 ) {
	            	var photoIndex = -1;
	            	for (var i = 0; i < m_camera_list.length; i++) {
					    if(intersects[ 0 ].object.id == m_camera_list[i].mesh.id)
					    	photoIndex = i;
					}
					//console.log(photoIndex);
					//console.log(m_camera_list)
					//console.log(captureNames)
					//m_controls.coupleCenters = false;
					//showCapture(photoIndex);
	                intersects[ 0 ].object.material.color.setHex( 0x0000ff );
	                intersects[ 0 ].object.material.opacity = 0.3; 
	                var direction = new THREE.Vector3();
					intersects[ 0 ].object.getWorldDirection( direction );
					//m_controls.enabled = false;
					//m_camera.position.copy( intersects[ 0 ].object.position )
					m_camera.position.copy( intersects[ 0 ].object.position ).add( direction.multiplyScalar( 0.09 ) );
					
					//m_camera.quaternion.copy( intersects[ 0 ].object.quaternion );

					var v1 = new THREE.Vector3(); // create once and reuse it

					v1.copy( intersects[ 0 ].object.up ).applyQuaternion( intersects[ 0 ].object.quaternion );
					m_camera.up.set(v1.x, v1.y, v1.z); 
					//m_camera.lookAt(intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z)
					m_controls.update()
					//m_controls.update()
					//m_controls.coupleCenters = true;
					
					m_controls.target = new THREE.Vector3( intersects[ 0 ].object.position.x, intersects[ 0 ].object.position.y, intersects[ 0 ].object.position.z );
					//m_controls.target.copy(v1.x, v1.y, v1.z)
					//m_controls.target.add( direction.multiplyScalar( 0.5 ) );
					m_controls.update()
					

	            }
	            else
	            {
	            	//document.getElementById("captureImage").style.visibility = "hidden";
	            	//console.log(m_camera)
	            	//console.log(controls)
	            }
	        }


	        function setDefaultColorsCameras()
	        {

	        	var arrayLength = m_camera_list.length;
				for (var i = 0; i < arrayLength; i++) {
				    m_camera_list[i].mesh.material.color.setHex( 0xffffff );
				    m_camera_list[i].mesh.material.opacity = 0.0; 
				    //Do something
				}
	        }
			function loadCamera(element, index, array)
			{
				
				//https://github.com/colmap/colmap/issues/797
				//https://github.com/colmap/colmap/issues/572
				console.log("      Loading Camera "+element.name+" ...")
				 const loader = new PLYLoader();
				 loader.load( './models/ply/ascii/camera.ply', function ( geometry ) {

				 	var m = new THREE.Matrix4();
					m.set( element.m1, element.m2, element.m3, element.tx,
			           element.m4, element.m5, element.m6, element.ty,
			           element.m7, element.m8, element.m9, element.tz,
			           0, 0, 0, 1 );
					m.invert();

					geometry.computeVertexNormals();
					const edges = new THREE.EdgesGeometry( geometry );
					//const material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
					const material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
					material.transparent = true;
					material.opacity = 0.1; 
					//const mesh = new THREE.LineSegments( geometry, material );
					//const mesh = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } ) );
					const mesh = new THREE.Mesh( geometry, material );

					mesh.applyMatrix4(m);
					mesh.applyMatrix4(new THREE.Matrix4().makeScale(0.03, 0.03, 0.03))
					mesh.castShadow = false;
					mesh.receiveShadow = false;
					m_scene.add( mesh );



					var fov_y = 2*Math.atan(element.height/(2*element.f))
					var fov_x = 2*Math.atan(element.width/(2*element.f))


					//console.log("FOVS: "+fov_y + " "+fov_x)
					var capture_camera = new THREE.PerspectiveCamera( fov_y*(180/Math.PI), element.width / element.height, 0.01, 10 );


					capture_camera.position.set( mesh.position.x,mesh.position.y,mesh.position.z );
					capture_camera.name = element.name
						/////////////

						//capture_camera.setFocalLength(element.f*(180/3.14))
						var v1 = new THREE.Vector3();
					v1.copy(mesh.up ).applyQuaternion(mesh.quaternion );
					capture_camera.quaternion.copy(mesh.quaternion );
					capture_camera.up.set(v1.x, v1.y, v1.z); 

					//capture_camera.aspect = element.width/element.height;

					capture_camera.updateMatrixWorld();
					capture_camera.updateProjectionMatrix();
					
					////////////////////////

					const texture_sprite = new THREE.TextureLoader().load( 'captures/'+element.name);
					const material_sprite = new THREE.SpriteMaterial( { map: texture_sprite } );
					material_sprite.onBeforeCompile = onBeforeCompile;
					const sprite = new THREE.Sprite( material_sprite );
					//m_scene.add( sprite );


					var new_camera = {
						name: element.name,
						width: element.width,
						height: element.height,
						matrix: m,
						focal: element.f,
						mesh: mesh,
						sprite: sprite,
						camera: capture_camera,
						similitudes: [],
						similitudes_indices_ordered: [],
						rays: [],
					}
					m_camera_list.push(new_camera);
					/*var loader2 = new THREE.TextureLoader();
					var texture = loader2.load( "./captures/"+element.name, function ( tex ) {
					    // tex and texture are the same in this example, but that might not always be the case
					    new_camera.width = tex.image.width
					    new_camera.height = tex.image.height
					    capture_camera.aspect = new_camera.width/new_camera.height;
					    //console.log( tex.image.width, tex.image.height );
					    //console.log( texture.image.width, texture.image.height );
					} );*/

					m_camera_mesh_list.push(mesh);
					setDefaultColorsCameras()
					m_application_state.num_cameras_loaded +=1

					var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
					document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";
					if(m_min_pos == null)
					{
						m_min_pos = new THREE.Vector3(mesh.position.x,mesh.position.y,mesh.position.z)
					}
					if(m_max_pos == null)
					{
						m_max_pos = new THREE.Vector3(mesh.position.x,mesh.position.y,mesh.position.z)
					}
					if(m_min_pos.x > mesh.position.x)
						m_min_pos.x = mesh.position.x
					if(m_min_pos.y > mesh.position.z)
						m_min_pos.y = mesh.position.z
					if(m_min_pos.z > mesh.position.z)
						m_min_pos.z = mesh.position.z

					if(m_max_pos.x < mesh.position.x)
						m_max_pos.x = mesh.position.x
					if(m_max_pos.y < mesh.position.z)
						m_max_pos.y = mesh.position.z
					if(m_max_pos.z < mesh.position.z)
						m_max_pos.z = mesh.position.z
					console.log("      Loading Camera "+element.name+" : DONE")
					//console.log("CAMERA LOADED")

				} );

			}
			
			function loadCameras(cameras) {
				m_application_state.num_cameras_to_load = cameras.cameras.length
				console.log("INFO: Loading cameras...")
				cameras.cameras.forEach(loadCamera);
			}
			
			function loadDoma()
			{
				console.log("INFO: Loading Doma...")
				const loader = new PLYLoader();
				const loaderTex = new THREE.TextureLoader(m_manager);

				loader.load( './models/ply/ascii/doma-interior_textured.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					let uniforms = {
				        colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
				        colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)},
				        capturePos: {type: 'vec3', value: new THREE.Vector3(0,0,0)},
				        viewMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        projectionMatrixCapture: {type: 'mat4', value: new THREE.Matrix4()},
				        showRedArea: {type: 'bool', value: false},
				        //texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "./models/textures/doma-interior_texture16k.jpg" ) },
				        texture1: { type: "t", value: loaderTex.load('./models/textures/doma-interior_texture16k.jpg') }
				    }
					const material = new THREE.ShaderMaterial( { 
						uniforms: uniforms,
					    fragmentShader: fragmentShader(),
					    vertexShader: vertexShader(),
						//map: loaderTex.load('./models/textures/doma-interior_texture16k.jpg'), 
					} );
					const mesh = new THREE.Mesh( geometry, material );
					mesh.scale.multiplyScalar( 0.03 );
					//mesh.rotation.x = - Math.PI / 2;
					mesh.position.x = 0.0;
					mesh.position.y = 0.0;
					mesh.position.z = 0.0;
					
					 

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					m_scene.add( mesh );
					m_scene_models.push(mesh);

					//TODO Check cams loaded
					m_application_state.num_models_loaded +=1
					console.log("INFO: Loading Doma: DONE")
					var completation = Math.floor(((m_application_state.num_cameras_loaded+m_application_state.num_models_loaded*10)/(m_application_state.num_cameras_to_load+m_application_state.num_models_to_load*10))*80)
					document.getElementById("loadingText").innerHTML = "Loading: "+completation.toString() +"%";

					//precomputeRays()

				} );

				
			}
			function loadModels()
			{
				m_application_state.num_models_to_load = 1
				loadDoma();

				m_scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

				addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 );


			}
			function resetCamera()
			{
				initControls(m_camera_mode)
			}
			function toggleEnableCams()
			{
				m_cams_enabled = !m_cams_enabled;
				var arrayLength = m_camera_list.length;
				if(m_cams_enabled)
				{
					for (var i = 0; i < arrayLength; i++) {
					    m_camera_list[i].mesh.material.opacity = 0.1; 
					}
				}
				else
				{
					for (var i = 0; i < arrayLength; i++) {
					    m_camera_list[i].mesh.material.opacity = 0.0; 
					}
				}
			}
			function getScorePosition(index_cam)
			{
				var dist_max_aprox = (m_min_pos.distanceTo(m_max_pos))*2
				var dist = m_camera_list[index_cam].mesh.position.distanceTo(m_camera.position)
				if(dist > dist_max_aprox)
					dist = dist_max_aprox;
				return (dist_max_aprox-dist)/dist_max_aprox;
				
			}
			function getScoreRotation(index_cam)
			{
				var direction1 = new THREE.Vector3();
				var direction2 = new THREE.Vector3();
				m_camera_list[index_cam].mesh.getWorldDirection( direction1 );
				m_camera.getWorldDirection( direction2 );
				var dist = direction1.distanceTo(direction2);
				return dist/2;
				
			}
			function getScoreRays(index_cam, intersectsCamera, min_x, max_x, min_y, max_y)
			{
				//if(intersectsCamera.length == 0)
				//	return 1;
				/*var directionPhoto = new THREE.Vector3();
				m_camera_list[index_cam].getWorldDirection( directionPhoto );
				var raycasterPhoto =  new THREE.Raycaster(m_camera_list[index_cam].position, directionPhoto); 

				var intersectsPhoto = raycasterPhoto.intersectObjects( m_scene_models );  

				if(intersectsPhoto.length == 0)
					return 1;*/

				m_camera.updateProjectionMatrix();
				var count_inside_rays = 0

				for(var index_ray = 0; index_ray <m_camera_list[index_cam].rays.length; ++index_ray)
				{
					var projected = new THREE.Vector3();
					projected.copy(m_camera_list[index_cam].rays[index_ray])
					projected.project(m_camera)
					//console.log(projected)
					if(projected.x > min_x && projected.x < max_x && projected.y > min_y && projected.y < max_y)
					{
						//console.log("added " + index_cam)
						count_inside_rays = count_inside_rays +1
					}
						
				}
				if(m_camera_list[index_cam].rays.length > 0)
					return count_inside_rays/m_camera_list[index_cam].rays.length
				else
					return 0
				//return intersectsPhoto[0].point.distanceTo(intersectsCamera[0].point);
				

			}
			function getScoreCam(index_cam, intersectsCamera, usingSelectionRectangle)
			{
				var distanceScore, orientationScore, raysScore;
				distanceScore = orientationScore = raysScore = 0;
				if(usingSelectionRectangle)
				{
					raysScore = getScoreRays(index_cam, intersectsCamera,m_selection_rectangle.startNDC.x,m_selection_rectangle.endNDC.x,m_selection_rectangle.startNDC.y,m_selection_rectangle.endNDC.y);
					return raysScore;
				}
				else
				{
					if(m_gui_options.position)
						distanceScore = getScorePosition(index_cam);
					if(m_gui_options.orientation)
						orientationScore = getScoreRotation(index_cam);
					if(m_gui_options.projection)
						raysScore = getScoreRays(index_cam, intersectsCamera,-1,1,-1,1);
					return distanceScore*m_gui_options.position + orientationScore*m_gui_options.orientation + raysScore*m_gui_options.projection;
				}

				
			}
			function compareCanditateIndices( a, b ) {
			  if ( a.index < b.index ){
			    return -1;
			  }
			  if ( a.index > b.index ){
			    return 1;
			  }
			  return 0;
			}
			function compareCandidates( a, b ) {
			  if ( a.score > b.score ){
			    return -1;
			  }
			  if ( a.score < b.score ){
			    return 1;
			  }
			  return 0;
			}
			function compareSimilitudes( a, b ) {
			  if ( a.similitude > b.similitude ){
			    return -1;
			  }
			  if ( a.similitude < b.similitude ){
			    return 1;
			  }
			  return 0;
			}
			function updateCandidateCollections()
			{
				var aux_candidate_list = []
				for (var i = 0; i < m_current_candidates.length; i++) {
					aux_candidate_list.push(m_current_candidates[i])
				}
				aux_candidate_list.sort(compareCanditateIndices)
				m_current_candidates_collections = []
				var current_collection_index = 0
				for (var i = 0; i < m_current_candidates.length; i++) {
					if(m_current_candidates[i].collection_index == -1 && m_current_candidates_collections.length < m_gui_options.max_num_collections)
					{
						var aux_collection_elem = {
							score: m_current_candidates[i].score,
							elems: [m_current_candidates[i].index]
						}
						m_current_candidates_collections.push(aux_collection_elem)
						m_current_candidates[i].collection_index=current_collection_index;
						var reached_treshold = false;
						var aux_index_capture = 0;
						while(m_current_candidates_collections[current_collection_index].elems.length < m_gui_options.max_collection_size && !reached_treshold && aux_index_capture < m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered.length)
						{
							if(m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].similitude > m_gui_options.similitude_treshold)
							{
								if(aux_candidate_list[m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index].collection_index == -1)
								{
									aux_candidate_list[m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index].collection_index = current_collection_index;

									m_current_candidates_collections[current_collection_index].elems.push(m_camera_list[m_current_candidates[i].index].similitudes_indices_ordered[aux_index_capture].index)
								}
							}
							else
							{
								reached_treshold = true;
							}
							aux_index_capture = aux_index_capture+1;
						}
						current_collection_index = current_collection_index +1
					}
					else if(m_current_candidates_collections.length >= m_gui_options.max_num_collections)
						break;
				}

			}
			function normalizeScores()
			{
				var biggest_score = m_current_candidates[0].score;
				for (var i = 0; i < m_current_candidates.length; i++) {
					m_current_candidates[i].score = m_current_candidates[i].score/biggest_score;
				}
			}
			function updateCandidates(usingSelectionRectangle)
			{
				console.log("INFO: Updating candidates...")
				var directionCamera = new THREE.Vector3();
				m_camera.getWorldDirection( directionCamera );
				var raycasterCamera =  new THREE.Raycaster(m_camera.position, directionCamera);    
				var intersectsCamera = raycasterCamera.intersectObjects( m_scene_models );  
				//console.log(intersectsCamera);

				var changed = false
				m_current_candidates = []
				var arrayLength = m_camera_list.length;
				for (var i = 0; i < arrayLength; i++) {
					
				    //m_camera_list[i].material.opacity = 0.1; 
				    var scoreCam = getScoreCam(i, intersectsCamera, usingSelectionRectangle)
				    var elem = {
					    'index': i,
					    'score': scoreCam,
					    'collection_index': -1,
					};
					//console.log(m_camera_list[i].name+" "+i + " score: "+ scoreCam)
					if(i >= m_current_candidates.length)
					{
						m_current_candidates.push(elem)
					}
				    else
				    {
				    	m_current_candidates[i] = elem
				    }
				}
				m_current_candidates.sort(compareCandidates)
				normalizeScores()
				updateCandidateCollections()
				if(m_current_capture_in_view_index == -1)
				{
					changeCaptureInView(m_current_candidates[0].index)
				}
				showCollections()
				//showCaptures(true)
				console.log("INFO: Updating candidates: DONE")
			}
			
			function changeMode()
			{
				if(m_camera_mode == "FLY")
					m_camera_mode = "ORBIT"
				else if(m_camera_mode == "ORBIT")
					m_camera_mode = "TRACK"
				else if(m_camera_mode == "TRACK")
					m_camera_mode = "FLY"
				else
					m_camera_mode = "FLY"
				initControls(m_camera_mode)
			}
			function initControls(mode)
			{
				m_camera_collections = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0, 10);
				m_scene_collections.add(m_camera_collections);

				m_camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.01, 10 );
				m_camera.position.set( 11*0.03,-20*0.03,2*0.03 );
				//camera.position.set( 3,0.15,3 );
				
				m_camera.up.set(0,0,1);

				m_camera_capture = new THREE.PerspectiveCamera( 50.5, 4000 / 2950, 0.01, 10 );
				m_camera_capture.position.set( 11*0.03,-20*0.03,2*0.03 );
				m_cameraHelper = new THREE.CameraHelper(m_camera_capture);
				m_scene.add(m_cameraHelper);
				//camera.position.set( 3,0.15,3 );
				
				m_camera_capture.up.set(0,0,1);


				if(mode == "FLY")
				{
					m_controls = new FlyControls( m_camera, m_renderer.domElement );
					m_controls.movementSpeed = 10;
					m_controls.domElement = m_renderer.domElement;
					m_controls.rollSpeed = Math.PI / 12;
					m_controls.autoForward = false;
					m_controls.dragToLook = false;
				}
				else if(mode == "ORBIT")
				{

					m_controls = new OrbitControls( m_camera, m_renderer.domElement );
					m_controls.minPolarAngle =  - Infinity; // radians
					m_controls.maxPolarAngle = Infinity; // radians
					m_controls.minDistance = 0;
					m_controls.maxDistance = 3;
					m_controls.minAzimuthAngle = - Infinity; // radians
					m_controls.maxAzimuthAngle = Infinity; // radians

					m_controls.target.set(-1*0.03,-20*0.03,2*0.03)

				}
				else if(mode == "TRACK")
				{
					m_controls = new TrackballControls( m_camera, m_renderer.domElement );
					m_controls.rotateSpeed = 1.0;
					m_controls.zoomSpeed = 0.6;
					m_controls.panSpeed = 0.2;

					m_controls.keys = [ 65, 83, 68 ];
					m_controls.target.set(-1*0.03,-20*0.03,2*0.03)
				}
				else
				{
					console.log("ERROR, mode "+mode+ " not found");
				}
			}
			function init() {

				
				m_container = document.createElement( 'div' );
				//const canvas = document.getElementById( 'canvas' );
				//canvas.width = 300 * window.devicePixelRatio;
				//canvas.height = 300 * window.devicePixelRatio;
				//const context = canvas.getContext( '2d' );
				document.body.appendChild( m_container );




				//camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
				//camera.position.set( 1000, 50, 1500 );

				//cameraTarget = new THREE.Vector3( 0, - 0.1, 0 );

				m_scene = new THREE.Scene();
				m_scene.background = new THREE.Color( 0x72645b );
				m_scene.fog = new THREE.Fog( 0x72645b, 2, 15 );

				m_scene_collections = new THREE.Scene();
				m_scene_collections.background = null;




				loadModels();



				// m_renderer
				var canvas = document.getElementById("canvas");
				m_renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
				m_renderer.setPixelRatio( window.devicePixelRatio );
				m_renderer.setSize( window.innerWidth, window.innerHeight );
				m_renderer.outputEncoding = THREE.sRGBEncoding;
				m_renderer.setClearColor(0xffffff, 0);
				m_renderer.shadowMap.enabled = true;
				m_renderer.autoClear = false; 


				

				m_container.appendChild( m_renderer.domElement );

				// stats

				m_stats = new Stats();
				m_container.appendChild( m_stats.dom );

				initControls(m_camera_mode)
				createGUI();
				




				window.addEventListener( 'resize', onWindowResize );
				
				animate();

				m_selection_rectangle.selectionBox = new SelectionBox( m_camera, m_scene );
				m_selection_rectangle.helper = new SelectionHelper( m_selection_rectangle.selectionBox, m_renderer, 'selectBox' );
				m_selection_rectangle.helper.element.hidden = true;
				document.addEventListener( 'pointerup', onDocumentPointerUp );
				document.addEventListener('pointermove', onDocumentPointerMove)
				document.addEventListener( 'pointerdown', onDocumentPointerDown );
				document.addEventListener("keydown", onDocumentKeyDown, false);
				m_container.appendChild( m_renderer.domElement );
				/*document.getElementById("captureImage6").onclick = function() {selectCapture(6);}
				document.getElementById("captureImage5").onclick = function() {selectCapture(5);}
				document.getElementById("captureImage4").onclick = function() {selectCapture(4);}
				document.getElementById("captureImage3").onclick = function() {selectCapture(3);}
				document.getElementById("captureImage2").onclick = function() {selectCapture(2);}
				document.getElementById("captureImage1").onclick = function() {selectCapture(1);}
				document.getElementById("captureImage0").onclick = function() {selectCapture(0);}*/

				document.addEventListener("keyup", event => {
				  if (/*event.isComposing || */event.keyCode === 17) {
				    m_select_controls_enabled = false;
					m_dragging = false

				    m_controls.enabled = true;

				    m_selection_rectangle.helper.element.hidden = true;
					/*m_canvas.setHeight(0);
					m_canvas.setWidth(0);*/
				  }
				});

				m_manager.onLoad = function()
				{
					//m_renderer.render( m_scene, camera );
				    console.log("INFO: DOMA_TEXTURE_LOADED");
				    animate()
				    
					m_application_state.textures_loaded = true
				}

				
				m_application_state.three_js_inited = true
			}

			function addShadowedLight( x, y, z, color, intensity ) {

				const directionalLight = new THREE.DirectionalLight( color, intensity );
				directionalLight.position.set( x, y, z );
				m_scene.add( directionalLight );

				directionalLight.castShadow = true;

				const d = 1;
				directionalLight.shadow.camera.left = - d;
				directionalLight.shadow.camera.right = d;
				directionalLight.shadow.camera.top = d;
				directionalLight.shadow.camera.bottom = - d;

				directionalLight.shadow.camera.near = 1;
				directionalLight.shadow.camera.far = 4;

				directionalLight.shadow.mapSize.width = 1024;
				directionalLight.shadow.mapSize.height = 1024;

				directionalLight.shadow.bias = - 0.001;

			}



			function onWindowResize() {

				m_camera.aspect = window.innerWidth / window.innerHeight;
				m_camera.updateProjectionMatrix();

				m_renderer.setSize( window.innerWidth, window.innerHeight );



				m_camera_collections.left = window.innerWidth / - 2;
				m_camera_collections.right =window.innerWidth / 2;
				m_camera_collections.top = window.innerHeight / 2;
				m_camera_collections.bottom = window.innerHeight / - 2;
				m_camera_collections.updateProjectionMatrix();

				m_captureShader.uniforms.resolution.value.set( window.innerWidth, window.innerWidth );
				/*if(m_select_controls_enabled)
				{
					m_canvas.setHeight(window.innerHeight);
				    m_canvas.setWidth(window.innerWidth);
				}
				else {
					m_canvas.setHeight(0);
			    	m_canvas.setWidth(0);
				}

			    m_canvas.renderAll();*/

			}

			function animate() {
				const timer = Date.now() * 0.0005;
				const delta = m_clock.getDelta();
				requestAnimationFrame( animate );

				switch(m_application_state.state)
				{
					case AppStates.READY_TO_GO:
					{
						if(m_need_to_update)
						m_timer_update += delta

						if(m_old_pos_cam.distanceTo(m_camera.position) > 0.0001)
						{
							//console.log("changed!! " + m_old_pos_cam.x + " " +m_camera.position.x)
							m_timer_update = 0;
							m_need_to_update = true;
						}
							
						
						if(m_camera_mode != "FLY")
							m_controls.update();
						m_stats.update();
						if(m_timer_update > m_gui_options.timer_recalc)
						{
							//console.log("update")
							m_need_to_update = false
							m_timer_update = 0
							if(m_gui_options.auto_score_enabled)
								updateCandidates(false);
						}
						if(m_camera_mode == "FLY")
						{
							m_controls.movementSpeed = 0.33 * 1;
							m_controls.update( delta );
						}
						m_old_pos_cam.copy(m_camera.position);

						m_scene_models[0].material.uniforms.showRedArea.value = m_gui_options.red_area_enabled;
						break
					}


					case AppStates.THREE_JS_INIT:
					{
						if(m_application_state.three_js_inited)
						{
							m_application_state.state = AppStates.LOADING_MESHES
						}
						break
					}
					case AppStates.LOADING_MESHES:
					{
						if(m_application_state.num_models_to_load == m_application_state.num_models_to_load && m_application_state.num_cameras_loaded == m_application_state.num_cameras_to_load)
						{
							document.getElementById("loadingText").innerHTML = "Loading: 80%";
							m_application_state.state = AppStates.LOADING_TEXTURES
						}
						break
					}
					case AppStates.LOADING_TEXTURES:
					{
						if(m_application_state.textures_loaded)
						{

							m_application_state.state = AppStates.LOADING_PRECOMPUTED_DATA
							var loader = new THREE.FileLoader();
					        loader.load('capture_info/precomputedCameraData.txt', function ( data ) {
							        // output the text to the console
							        loadPrecomputedFile(data)
							        m_application_state.precomputed_file_loaded = true
									document.getElementById("loadingText").innerHTML = "Loading: 90%";
							});
							
						}
						break
					}
					case AppStates.LOADING_PRECOMPUTED_DATA:
					{
						if(m_application_state.precomputed_file_loaded)
						{
							if(m_capture_rays_need_recomputation)
							{
								
								precomputeCaptureInfo(m_num_rays_precomputation,m_num_rays_precomputation,m_application_state.count_precomputation_iterations)
							}
							else
							{
								m_application_state.state = AppStates.READY_TO_GO
								document.getElementById("loadingText").innerHTML = "";
								document.getElementById("loadingTextContainer").style.visibility = "hidden";
								console.log("INFO: System ready to go!")
							}
							
						}
							
						break
					}
				}

				
				render();


			}

			function render() {
				//if ( windowWidth != window.innerWidth || windowHeight != window.innerHeight ) {

				//	windowWidth = window.innerWidth;
				//	windowHeight = window.innerHeight;

				m_renderer.setSize( window.innerWidth, window.innerHeight );

				//}
				m_cameraHelper.update();
				m_renderer.clear();
				if(m_gui_options.show_view_enabled && !m_select_controls_enabled)
				{
					//RENDER CAM 1
					{
						const left = Math.floor( window.innerWidth * m_views[0].left );
						const bottom = Math.floor( window.innerHeight * m_views[0].bottom );
						const width = Math.floor( window.innerWidth * m_views[0].width );
						const height = Math.floor( window.innerHeight * m_views[0].height );

						m_renderer.setViewport( left, bottom, width, height );
						m_renderer.setScissor( left, bottom, width, height );
						m_renderer.setScissorTest( true );

						m_camera.aspect = width / height;
						m_camera.updateProjectionMatrix();
						m_cameraHelper.visible = m_gui_options.show_camera_enabled;
						m_renderer.render( m_scene, m_camera );
					}
					//RENDER CAM 2
					{
						const left = Math.floor( window.innerWidth * m_views[1].left );
						const bottom = Math.floor( window.innerHeight * m_views[1].bottom );
						const width = Math.floor( window.innerWidth * m_views[1].width );
						const height = Math.floor( window.innerHeight * m_views[1].height );

						m_renderer.setViewport( left, bottom, width, height );
						m_renderer.setScissor( left, bottom, width, height );
						m_renderer.setScissorTest( true );

						m_camera_capture.aspect = width / height;
						m_camera_capture.updateProjectionMatrix();
						m_cameraHelper.visible = false;




						m_renderer.render( m_scene, m_camera_capture );
					}
				}
				else
				{
					const left = Math.floor( window.innerWidth * m_views[2].left );
					const bottom = Math.floor( window.innerHeight * m_views[2].bottom );
					const width = Math.floor( window.innerWidth * m_views[2].width );
					const height = Math.floor( window.innerHeight * m_views[2].height );

					m_renderer.setViewport( left, bottom, width, height );
					m_renderer.setScissor( left, bottom, width, height );
					m_renderer.setScissorTest( true );

					m_camera.aspect = width / height;
					m_camera.updateProjectionMatrix();
					m_cameraHelper.visible = m_gui_options.show_camera_enabled;
					m_renderer.render( m_scene, m_camera );
				}
				m_renderer.clearDepth();
				const left = Math.floor( window.innerWidth * m_views[2].left );
				const bottom = Math.floor( window.innerHeight * m_views[2].bottom );
				const width = Math.floor( window.innerWidth * m_views[2].width );
				const height = Math.floor( window.innerHeight * m_views[2].height );

				m_renderer.setViewport( left, bottom, width, height );
				m_renderer.setScissor( left, bottom, width, height );

				m_renderer.render( m_scene_collections, m_camera_collections );
				

			}
			function precomputeCaptureInfo(rays_x, rays_y, iteration)
			{
				

				precomputeRays(rays_x, rays_y, iteration);
				m_application_state.count_precomputation_iterations = m_application_state.count_precomputation_iterations +1
				if(m_application_state.count_precomputation_iterations == m_camera_list.length)
				{
					m_capture_rays_need_recomputation = false
					precomputeCaptureSimilitude();
					savePrecomputedFile()
					m_application_state.precomputation_done = true
					m_application_state.count_precomputation_iterations = 0
				}
				
				
			}
			function precomputeRays(rays_x, rays_y, i)
			{
				console.log("INFO: precomputing rays...")
				//for (var i = 0; i < m_camera_list.length; i++) 
				{
					m_camera_list[i].camera.updateProjectionMatrix()
					m_camera_list[i].rays = []
					for(var x = 0; x <= 1; x +=(1/(rays_x-1)))
					{
						for(var y = 0; y <= 1; y +=(1/(rays_y-1)))
						{

							var NDC_position = new THREE.Vector3(x*2-1,y*2-1,1);
							var pointIntersect = new THREE.Vector3();
							NDC_position.unproject(m_camera_list[i].camera);
							var test_ray = new THREE.Vector3();

							//m_camera_list[i].getWorldDirection( directionPhoto );
							var raycasterPhoto =  new THREE.Raycaster(m_camera_list[i].mesh.position, NDC_position); 

							var intersectsPhoto = raycasterPhoto.intersectObjects( m_scene_models );  
							//console.log(intersectsPhoto)
							if(intersectsPhoto.length > 0)
							{
								pointIntersect.copy(intersectsPhoto[0].point)
								m_camera_list[i].rays.push(pointIntersect)
							}
						}
					}
					var completation = Math.floor((i/m_camera_list.length)*90)

					document.getElementById("loadingText").innerHTML = "Precomputing rays: "+completation.toString() +"%";

					console.log("      finished precomputing capture positions for cam: "+i+" , rays found: "+m_camera_list[i].rays.length)
				}
				
				console.log("INFO: finished precomputing rays")
				
			}
			function computeSimilitudeForCams(cam1, cam2)
			{
				
				var count_inside_rays_cam1 = 0
				var count_inside_rays_cam2 = 0
				var rate_cam1 = 0;
				var rate_cam2 = 0;
				for(var index_ray = 0; index_ray <cam1.rays.length; ++index_ray)
				{
					var projected = new THREE.Vector3();
					projected.copy(cam1.rays[index_ray])
					projected.project(cam2.camera)
					//console.log(projected)
					if(projected.x > -1.0 && projected.x < 1.0 && projected.y > -1.0 && projected.y < 1.0)
					{
						//console.log("added " + index_cam)
						count_inside_rays_cam1 = count_inside_rays_cam1 +1
					}
						
				}
				if(cam1.rays.length > 0)
					rate_cam1 = count_inside_rays_cam1/cam1.rays.length;

				for(var index_ray = 0; index_ray <cam2.rays.length; ++index_ray)
				{
					var projected = new THREE.Vector3();
					projected.copy(cam2.rays[index_ray])
					projected.project(cam1.camera)
					//console.log(projected)
					if(projected.x > -1.0 && projected.x < 1.0 && projected.y > -1.0 && projected.y < 1.0)
					{
						//console.log("added " + index_cam)
						count_inside_rays_cam2 = count_inside_rays_cam2 +1
					}
						
				}
				if(cam2.rays.length > 0)
					rate_cam2 = count_inside_rays_cam2/cam2.rays.length;

				return (rate_cam1+rate_cam2)/2
			}
			function computeSimilitudesIndicesOrdered()
			{
				for(var index_cam=0; index_cam < m_camera_list.length; ++index_cam)
				{	
					m_camera_list[index_cam].similitudes_indices_ordered = []
					for(var index_cam2=0; index_cam2 < m_camera_list[index_cam].similitudes.length; ++index_cam2)
					{
						var curr_sim = 
						{
							index: index_cam2,
							similitude: m_camera_list[index_cam].similitudes[index_cam2]
						}
						m_camera_list[index_cam].similitudes_indices_ordered.push(curr_sim)
					}
					m_camera_list[index_cam].similitudes_indices_ordered.sort(compareSimilitudes)
				}
			}
			function precomputeCaptureSimilitude()
			{
				console.log("INFO: Precomputing Similitudes....")
				for(var index_cam=0; index_cam < m_camera_list.length; ++index_cam)
				{	
					m_camera_list[index_cam].similitudes = []
					for(var index_cam2=0; index_cam2 < m_camera_list.length; ++index_cam2)
					{
						m_camera_list[index_cam].similitudes.push(computeSimilitudeForCams(m_camera_list[index_cam],m_camera_list[index_cam2]))
					}
					//var completation = Math.floor((index_cam/m_camera_list.length)*50+50)

					//document.getElementById("loadingText").innerHTML = "Precomputed rays not found, precomputing again: "+completation.toString() +"%";
				}
				computeSimilitudesIndicesOrdered()
				console.log("INFO: Precomputing Similitudes: DONE")
			}

			function loadPrecomputedFile(data)
			{
				console.log("INFO: Loading Precomputed File...")
				var data_cameras = data.split('\n');
				if(data_cameras.length != m_camera_list.length)
				{
					m_capture_rays_need_recomputation = true
					console.log("INFO: Precomputed File outdated, need to recompute")
					return
				}
				else
				{
					for(var index_cam=0; index_cam < data_cameras.length; ++index_cam)
					{
						m_camera_list[index_cam].rays = []
						var data_camera = data_cameras[index_cam].split(' ')
						while(data_camera[0] == "")
							data_camera.shift()
						var num_rays = data_camera[0]

						for(var ray = 0; ray < num_rays; ++ray)
						{
							var x = data_camera[ray*3+1]
							var y = data_camera[ray*3+1+1]
							var z = data_camera[ray*3+1+2]
							var position_ray = new THREE.Vector3(x,y,z);
							m_camera_list[index_cam].rays.push(position_ray);
						}
						m_camera_list[index_cam].similitudes = []
						for(var simil_cam_index = 0; simil_cam_index <m_camera_list.length; ++simil_cam_index)
						{
							var simil = data_camera[num_rays*3+1+simil_cam_index]
							m_camera_list[index_cam].similitudes.push(simil)
						}
					}
					m_capture_rays_need_recomputation = false
					computeSimilitudesIndicesOrdered()
				}
				console.log("INFO: Loading Precomputed File: DONE")

				
				
					
			}
			function savePrecomputedFile()
			{
				console.log("INFO: Saving Precomputed File...")
            	var parts = []
				for(var index_cam=0; index_cam < m_camera_list.length; ++index_cam)
				{	

					parts.push(m_camera_list[index_cam].rays.length);

					for(var index_ray=0; index_ray < m_camera_list[index_cam].rays.length; ++index_ray)
					{
						var raypos = m_camera_list[index_cam].rays[index_ray]
						parts.push(" " + raypos.x + " " + raypos.y + " " + raypos.z);
					}
					for(var index_sim=0; index_sim < m_camera_list[index_cam].similitudes.length; ++index_sim)
					{
						var sim = m_camera_list[index_cam].similitudes[index_sim]
						parts.push(" " + sim);
					}
					if(index_cam < m_camera_list.length -1)
						parts.push("\n");
				}
				var blob = new Blob(parts);
				saveAs(blob, 'precomputedCameraData.txt')
				console.log("INFO: Saving Precomputed File: DONE")
			}

			var xmlhttp = new XMLHttpRequest();
			xmlhttp.onreadystatechange = function() {
			    if (this.readyState == 4 && this.status == 200) {
			        var myObj = JSON.parse(this.responseText);
			        console.log("INFO: Capture info json loading... DONE")
			        loadCameras(myObj)
			        setDefaultColorsCameras();
			    }
			};
			xmlhttp.open("GET", "capture_info/cameraInfo.json", true);
			console.log("INFO: Capture info json loading...")
			xmlhttp.send();

		</script>
	</body>
</html>
